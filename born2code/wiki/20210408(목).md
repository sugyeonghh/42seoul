## 1. 학습 날짜

* 2021-04-08(목)



## 2. 학습 시간

* 12:00 ~ 15:30 (자가)
* 16:50 ~ 19:30 (카페)



## 3. 학습 범위 및 주제

* 리눅스 프로그래밍
* 정보처리기사 실기



## 4. 동료 학습 방법

* 해당 사항 없음



## 5. 학습 목표

* 리눅스 프로그래밍 학습
* 정보처리기사 실기  준비



## 6. 상세 학습 내용

#### 1. 리눅스 프로그래밍 - 파일 입출력 (시스템 콜)

* open: 이미 존재하고 있는 파일을 열거나 파일이 없는 경우 새롭게 생성하여 연다
  * `int open(const char* path, int flags, ...)`
  * `path` : 열고 싶은 파일의 경로, 절대 경로 또는 상대 경로로 표현 가능
  * `flags` : 파일을 열 때 사용할 수 있는 플래그(옵션) 값을 명시
    * `O_RDONLY` : 읽기 전용 
    * `O_WRONLY` : 쓰기 전용
    * `O_RDWR` : 읽기/쓰기 모두 가능  
    * `O_CREAT` : 파일이 없을 경우 파일을 생성
    * `O_EXCL` : 파일이 있는 경우에 에러 발생시킴
    * `O_APPEND` : 쓰기 작업 수행시 파일의 끝에 새로운 내용 추가 
    * `O_TURNC` : 기존의 파일의 내용이 있으면 지움
  * `mode` : 파일 생성 시 설정되는 접근 권한 (permission)
  * 반환값
    * 함수 실행이 성공하면 `0, 1, 2` 이외의 0보다 큰 `file descriptor` 를 반환
    * 실패하면 `-1` 반환
* creat: 비어있는 새로운 파일 생성하여 연다
  * `int creat(const char* path, mode_t mode)`
  * `path` : 열고 싶은 파일의 경로, 절대 경로 또는 상대 경로 표현 가능
  * `mode` : 접근 권한을 설정
  * 반환값
    * 함수 실행이 성공하면 `0, 1, 2` 이외의 0보다 큰 `file descriptor` 를 반환
    * 실패하면 `-1` 반환
* close: `open` 또는 `creat` 함수에 의해 열린 파일을 닫음
  * `int close(int fd)`
  * `fd` : 열려있는 파일 디스크립터
  * 반환값
    * 파일 열기에 성공하면 `0` 반환
    * 실패하면 `-1` 반환
  * 파일을 열고, 읽고, 쓰는데 사용된 메모리의 버퍼를 해제하기 위해 사용한 파일은 반드시 닫아야함
* read: 파일 디스크립터를 이용하여 열려 있는 파일로부터 데이터를 읽어옴
  * `ssize_t read(int fd, void *buf, size_t count)`
  * `fd` : 열려있는 파일 디스크립터
  * `buf` : 읽어 들인 데이터를 저장하는 버퍼의 포인터형 변수, 일반적으로 배열을 사용
  * `count` : 읽어 들일 데이터의 최대 크기 (byte)
  * 반환값
    * 함수 실행에 성공시
      * `실제로 읽어들인 데이터의 크기(byte)` 반환
      * `EOF` 를 만나면 `0` 을 반환 (읽어 들일 데이터가 없기 때문)
    * 실패하면 `-1` 반환
* write: 파일 디스크립터를 이용하여 열려 있는 파일에 데이터를 씀
  * `ssize_t write(int fd, const void* buf, size_t count)`
  * `fd` : 열려있는 파일 디스크립터
  * `buf` : 쓸 데이터를 저장하는 버퍼의 포인터형 변수
  * `count` : 실제로 쓸 데이터의 크기(byte)
  * 반환값
    * 함수 실행에 성공하면 `실제로 쓴 데이터의 크기(byte)` 반환
    * 실패하면 `-1` 반환
      * 반환값과 `count` 의 값이 다르면 실패
      * HDD, SSD 와 같은 보조기억장치의 여유 공간이 부족할 때 발생
  * `offset` : 열린 파일 내에서 데이터의 읽기나 쓰기를 수행할 때 데이터에 대한 바이트 단위의 위치
    * 파일을 열었을 때 `offset` 은 파일의 첫 부분을 기준으로 `0` 값을 가짐
    * `read` 또는  `write` 를 하면서 읽히거나 쓰여진 데이터 만큼 `offset` 이 이동함
* lseek: 파일 디스크립터를 이용하여 열려 있는 파일 내의 `offset` 을 원하는 위치로 이동시킴
  * `off_t lseek(int fd, off_t offset, int whence)`
  * `fd` : 열려 있는 파일 디스크립터
  * `offset` : 기준점에서의 상대적인 위치, 음수가 될 수도 있으며 `byte` 단위로 지정
  * `whence` : 기준점
    * `SEEK_SET` : 파일의 첫 부분
    * `SEEK_CUR` : 현재 `offset` 의 위치
    * `SEEK_END` : `EOF`
  * 반환값
    * 함수 실행에 성공하면 파일 첫 부분( `SEEK_SET` ) 을 기준으로 상대적인 위치 ( `offset` ) 을 반환
    * 실패하면 `-1` 반환 



## 7. 학습 내용에 대한 개인적인 총평

* 대학교 강의에서 듣고있는데 이걸 보면서 42과제 `get_next_line` 이 생각났다. 덕분에 `offset` 을 조작하는 거나 `open`, `write` , `read` 함수를 사용해서 실습하는게 훨씬 쉽고 익숙했다. 확실히 한 번 코딩해서 익힌 건 다르다. 여기 실습 코드도 `get_next_line` 과 유사하다. 어쩌면 이걸 먼저 배웠으면 42 과제를 훨씬 쉽고 빠르게 했을지도 모르겠다. 좀 더 정확하고 자세하게 배우는 것 빼고는 이미 아는 내용이라 여유롭다. 오랜만에 여유로워서 좋다.



## 8. 다음 학습 계획

* 정보처리기사 실기

