## 1. 학습 날짜

* 2021-02-01(월)



## 2. 학습 시간

* 13:00 ~ 18:30 (자가)



## 3. 학습 범위 및 주제

* 백준 알고리즘
  * 1065 한수
  * 4673 셀프넘버



## 4. 동료 학습 방법

* 해당사항 없음



## 5. 학습 목표

* 백준 알고리즘 문제 2개 풀기



## 6. 상세 학습 내용

#### 1. 1065 한수

* 문제

  * 문제 설명

    * 어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오. 

  * 입력

    * 첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.

  * 출력

    * 첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다.

  * 예제 1

    * 입력

      ```
      110
      ```

    * 출력

      ```
      99
      ```

  * 예제 2

    * 입력

      ```
      210
      ```

    * 출력

      ```
      105
      ```

* 알고리즘

  * 1 ~ 99 까지 등차수열 -> 최소한 자리수가 3자리 이상이어야 등차수열인지 아닌지 구분할 수 있음

  * 따라서 1 ~ 99 까지의 숫자가 들어오면 그 숫자가 등차수열의 개수이다.

  * N이 100이상의 값이라면

    * 한수의 개수를 세는 cnt 변수를 선언해서 초기값으로 99를 준다. (100까지의 한수의 개수가 99개이기 때문)
    * 100부터 N까지 반복문을 돌면서 각각의 숫자의 일의자리수, 십의자리수, 백의자리수를 구한 다음, (백의 자리수 - 십의 자리수) 와 (십의 자리수 - 백의 자리수)가 같은지 확인한 후에, 같다면 cnt 를 증가시킨다.
    * 반복문이 끝나면 cnt를 반환한다.

  * 코드

    ```c
    int		han_number(int N)
    {
    	int hundreds;
    	int tens;
    	int units;
    	int cnt;
    
    	if (N < 100)
    		return (N);
    	cnt = 99;
    	for (int i = 100; i <= N; i++)
    	{
    		hundreds = i / 100;
    		tens = (i / 10) % 10;
    		units = i % 10;
    		if ((hundreds - tens) == (tens - units))
    			cnt++;
    	}
    	return (cnt);
    }
    ```

    

<hr>

#### 2. 4673 셀프넘버

* 문제

  * 문제 설명

    * 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.

      양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다. 

      예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.

      33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...

      n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 

      생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97

      10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.

  * 입력

    * 없음

  * 출력

    * 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.

  * 예제 1

    * 출력

      ```
      1
      3
      5
      7
      9
      20
      31
      42
      53
      64
       |
       |       <-- a lot more numbers
       |
      9903
      9914
      9925
      9927
      9938
      9949
      9960
      9971
      9982
      9993
      ```



* 알고리즘

  * define N 10001

  * nums[N] 선언 후, 0으로 초기화

  * d(n) 값은 무조건 셀프넘버가 아니므로 인덱스가 d(n)인 배열 값을 1로 바꾼다. 

    * 단, d(n) 값이 N을 넘지 않을때만 값을 바꾸어주어야 segfault가 발생하지 않는다.

  * d() 함수는 각 자리수를 더해서 반환하는 과정만으로 충분하다.

  * 배열에 저장된 값이 0인 것을 출력한다.

  * 코드

    ```c
    #define N 10001
    
    int		d(int n)
    {
    	int	sum;
    
    	sum = n;
    	while (n)
    	{
    		sum += (n % 10);
    		n /= 10;
    	}
    	return (sum);
    }
    
    int		main(void)
    {
    	int	nums[N] = {0,};
    	int idx;
    
    	for (int i = 1; i < N; i++)
    		if ((idx = d(i)) < N)
    			nums[idx] = 1;
    	for (int i = 1; i < N; i++)
    		if (!nums[i])
    			printf("%d\n", i);
    	return (0);
    }
    ```

    

## 7. 학습 내용에 대한 개인적인 총평

* 전에 생각하기 어렵다고 생각해서 안풀었던 문젠데 생각보다 쉽게 풀려서 놀랐다. 내가 실력이 늘었는지는 잘 모르겠지만, 지난번 보다 쉽게 접근하긴 했다. 문제를 풀고 제출했는데 0ms이 뜨면서 바로 통과돼서 기분이 좋았다.
* 오랜만에 백준을 풀었는데 생각보다 잘풀려서 뿌듯했다. 내일도 풀어야겠다. 지난주에 get_next_line과 printf를 달렸는데, printf가 막혀서 하기 싫었다. 이럴때 백준을 풀어야 잘 풀리는 것 같다. 한편으로는 도피성이라 한심하긴 하지만, 그래도 덕분에(?) 백준을 풀 수 있으니 다행이다.



## 8. 다음 학습 계획

* 백준 알고리즘 2개 이상 풀기
* get_next_line 동료평가 받기



