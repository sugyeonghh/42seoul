## 1. 학습 날짜

2021-01-11(월)


## 2. 학습 시간

* 15:00 ~ 20:00 (자가)


## 3. 학습 범위 및 주제

* 백준 알고리즘
	* 브루트 포스(brute force; 무차별 대입 공격): 모든 경우의 수를 검사
		* 7568 덩치
		* 1018 체스판 다시 칠하기


## 4. 동료 학습 방법

* 디스코드를 통한 알고리즘 학습 (intra ID: jji, jiwchoi, yoncho)


## 5. 학습 목표

* 백준 (코딩 사이트)에 있는 문제 풀기


## 6. 상세 학습 내용

* 브루트 포스(brute force; 무차별 대입 공격): 모든 경우의 수를 검사해서 결과를 도출하는 알고리즘
#### 1. 7568 덩치
* 문제
	* A의 몸무게와 키가 B의 몸무게와 키보다 클 때, A의 덩치가 더 크다
	* 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.
	* 덩치 등수를 계산하여 출력하라.

* 입력
	* 첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.

* 출력
	* 여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.

* 예제 1
	* 입력
		```
		5
		55 185
		58 183
		88 186
		60 175
		46 155
		```
	
	* 출력 
		```
		2 2 1 2 5
		```

* 알고리즘
	* 변수
		* N: 입력받을 사람 수
		* *weight: 입력받은 몸무게 값을 저장할 배열
		* *high: 입력받은 키 값을 저장할 배열
		* k: 덩치 계산을 위한 변수
		* *res: 최종 덩치 등수 배열
	* N 명의 몸무게와 키를 입력받아와서 각각 배열로 저장한다.
	* for 문을 이중 중첩해서 몸무게와 키가 둘 다 크면 k를 증가시킨다.
	* 최종 저장된 k 를 res 배열에 저장한다.
	* 배열 res를 출력한다.
	* 코드
		```
		for (int i = 0; i < N; i++)
		{
			k = 0;
			for (int j = 0; j < N; j++)
			{
				if (i == j)
					continue;
				if ((weight[i] < weight[j]) && (high[i] < high[j]))
					k++;
			}
			res[i] = k + 1;
		}
		```


<hr>

#### 2. 1018 체스판 다시 칠하기
* 문제
	* (M * N) 크기의 보드를 입력받고 그 안에서 (8 * 8) 크기의 체스판을 찾는다. 보드가 체스판처럼 칠해져 있다는 보장이 없기 때문에 새롭게 칠해야하는데, 다시 칠해야 하는 정사각형의 최소 개수를 구하시오.
	* 체스판의 패턴: WBWB가 교차된 상태

* 입력
	* 첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.

* 출력
	* 첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.

* 예제 1
	* 입력
		```
		8 8
		WBWBWBWB
		BWBWBWBW
		WBWBWBWB
		BWBBBWBW
		WBWBWBWB
		BWBWBWBW
		WBWBWBWB
		BWBWBWBW
		```

	* 출력
		```
		1
		```

* 예제 2
	* 입력
		```
		10 13
		BBBBBBBBWBWBW
		BBBBBBBBBWBWB
		BBBBBBBBWBWBW
		BBBBBBBBBWBWB
		BBBBBBBBWBWBW
		BBBBBBBBBWBWB
		BBBBBBBBWBWBW
		BBBBBBBBBWBWB
		WWWWWWWWWWBWB
		WWWWWWWWWWBWB
		```

	* 출력
		```
		12
		```

* 알고리즘
	* 변수
		* N: 행
		* M: 열
		* start_W = "WBWBWBWB" : W로 시작한 체스 패턴
		* start_B = "BWBWBWBW" : B로 시작한 체스 패턴
		* cnt: 현재 보드에서 다시 칠해야 하는 정사각형의 개수의 최소값
		* res: 모든 경우의 수 중 가장 작은 값
		* (이중포인터)board: 입력받은 보드
	
	* 함수
		* find_arr: 다시 칠해야 하는 정사각형의 최소 개수를 찾는 함수 (W로 시작하거나 B로 시작하는 패턴으로 검사해서 최소값을 도출)
			`find_arr(char **board, int x, int y, char *compare1, char *compare2)`
			* 정해진 패턴과 비교해서 다르면 cnt(지역변수) 증가 후 반환

	* (N * M) 크기의 배열을 입력받아서 board 에 저장 
	* for 문을 이중 중첩으로 사용해서 board 의 처음부터 접근해서 (8 * 8) 체스판을 찾음
		* 체스판이 (N * M) 범위를 넘어가면 함수를 호출하지 않고 넘어감
	 	* W 로 시작하는 체스판과 B 로 시작하는 체스판 두 경우를 모두 계산해서 둘 중 최소값을 cnt 에 저장한 후, 그 값이 최종 값인 res 보다 작으면 res에 cnt를 저장한다
	* 최종 저장된 res 를 출력
	* 코드
		```
		for (int i = 0; i < N; i++)
		{
			cnt = 0;
			for (int j = 0; j < M; j++)
			{
				if ((i + 7 >= N) || (j + 7 >= M))
					continue;
				int W = find_arr(board, i, j, start_W, start_B);
				int B = find_arr(board, i, j, start_B, start_W);
				cnt = W < B ? W : B;
				res = cnt < res ? cnt : res;
			}
		}
		```


## 7. 학습 내용에 대한 개인적인 총평

* [체스판 다시 칠하기] 문제에서 함수에 (i 값, j 값)을 넘기는데 그걸 잘못 사용한 것을 모르고 있다가 계속 틀려서 오류 찾는 데만 많은 시간이 걸렸다. 괜히 프로토타입에 (x, y)로 썼다가 헷갈렸다. 변수 이름을 더 정확하게 사용해야겠다. 
* 아직도 행과 열에 대해서 헷갈려 하는 게 웃기다. 언제쯤 헷갈리지 않고 바로 사용할 수 있을까. 코딩을 더 많이 해봐야겠다. 사실 get_next_line도 빨리 해야하는데 너무 어려워서 자꾸만 미루게 되고, 다른 쉬운 거를 찾게 된다. 근데 쉬운 것에서도 실수가 많이 나오니 아쉽고 착잡하다. 별거 아닌거에 에너지를 쏟는 게 아쉽고 아깝다. 


## 8. 다음 학습 계획

* 백준 알고리즘 문제 2개 풀기
* netwhat
