## 1. 학습 날짜

2021-01-18(월)


## 2. 학습 시간

* 00:10 ~ 04:40 (자가)


## 3. 학습 범위 및 주제

* 프로그래머스 스택/큐

## 4. 동료 학습 방법

* 디스코드를 통해 알고리즘 구현 방법 설명 및 공유 (intra ID: yoncho)

## 5. 학습 목표

* 프로그래머스 스택/큐
	* 주식가격
	* 기능개발


## 6. 상세 학습 내용

#### 1. 주식 가격
* 문제
	* 초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.

* 제한 사항
	* prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.
	* prices의 길이는 2 이상 100,000 이하입니다.

* 예제 1
	* 입력
	```
	
    [1, 2, 3, 2, 3]
    ```
	* 출력
	```
    [4, 3, 1, 1, 0]
    ```
	* 설명
		* 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.
		* 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.
		* 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.
		* 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.
		* 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.

* 알고리즘
	* 변수
		* answer 리스트: 반환값
		* p_len: 입력된 주식가격 배열의 길이
		* p: 주식가격 임시 저장 변수
		* cnt: 주식 각격이 유지되는 시간을 계산하는 변수

	* 주식 가격의 길이만큼 for 문을 돌려서 그 다음 가격들과 비교해서 주식 가격이 유지되는 시간을 구한다.
	* 만약 주식 가격이 떨어지면 반복문을 빠져나온 뒤 결과 배열에 주식 가격이 유지된 시간을 저장한다.

	* 코드
    ```
    def solution(prices):
        answer = []
        p_len = len(prices)
        for i in range(p_len):
            p = prices[i]
            cnt = 0
            for j in range(i + 1, p_len):
                cnt += 1
                if p > prices[j]:
                    break
            answer.append(cnt)
        return answer
    ```

<hr>

#### 2. 기능 개발
* 문제
	* 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.
	* 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.
	* 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

* 제한 사항
	* 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
	* 작업 진도는 100 미만의 자연수입니다.
	* 작업 속도는 100 이하의 자연수입니다.
	* 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.

* 예제 1
	* 입력
    ```
    progress [93, 30, 55]
    speeds [1, 30, 5]
    ```

	* 출력
	```
	[2, 1]
    ```

* 예제 2
	* 입력
	```
    progress [95, 90, 99, 99, 80, 99]
    speeds [1, 1, 1, 1, 1, 1]
    ```

	* 출력
    ```
    [1, 3, 2]	
    ```

* 알고리즘
	* 변수
		* answer 리스트: 반환값
		* p 리스트: 각 프로세스를 실행하는 데 걸리는 시간들
			* 각 프로세스의 남은 퍼센테이지를 구한 뒤(100 - 현재 프로세스) 각자의 speeds로 나눠준 값을 값 올림한 수가 프로세스를 실행하는 데 걸리는 시간이다.
			* math.ceil() 함수를 사용해서 올림을 해준다.
            
			```
            for i in progresses:
        		p.append(math.ceil((100 - i) / speeds.pop(0)))
            ```
			
            
		* tmp 리스트: 각 프로세스 임시 저장 리스트
	
	* 함수
		* math.ceil(): 올림 함수
	
	* p 리스트에 각 프로세스를 실행하는 데 걸리는 시간을 저장한다.
	* tmp 리스트에 p 리스트 첫 번째 값을 pop 해서 저장한다.
	* p 리스트의 길이만큼 반복문을 돌리면서 원래 프로세스보다 그 다음 프로세스의 남은 시간이 더 작으면 tmp 에 추가하고, 그렇지 않으면 answer 리스트에 현재 tmp 의 길이를 저장하고 tmp를 초기화한 후 현재 프로세스 값을 저장한다.

	* 코드
	```
    import math

	def solution(progresses, speeds):
		answer = []
		p = []
		tmp = []
		for i in progresses:
			p.append(math.ceil((100 - i) / speeds.pop(0)))
		tmp.append(p.pop(0))
		for i in p:
			if i <= tmp[0]:
				tmp.append(i)
			else:
				answer.append(len(tmp))
				tmp = []
				tmp.append(i)     
		answer.append(len(tmp))
		return answer
    ```


## 7. 학습 내용에 대한 개인적인 총평

* 오랜만에 프로그래머스 문제를 풀었다. yoncho 가 다른 분과 알고리즘 풀기를 진행하기에 나도 따라서 풀었다. 백준과 달리 main 함수 없이 주어진 함수만 작성하면 되기 때문에 훨씬 쉬웠지만 프로그래머스에는 C 언어가 없기 때문에 파이썬으로 작성할 수 밖에 없었다. 문제는 C 언어를 오래 접하다보니 파이썬을 잊어버려서 알고리즘을 C 언어 적으로만 생각하게 됐다는 것이다. 결과적으로 코드의 길이는 짧지만 알고리즘을 파이썬에 맞춰 생각하느라 더 오래걸렸다. 또, 파이썬으로 하니까 효율성 테스트에서 통과하지 못해서 그걸 고치느라 오래걸렸다. 오랜만에 새로운 언어로 작성하려니까 이렇게 되는 것 같다. 앞으로는 파이썬도 매일 풀어야하나 하는 걱정이 앞선다. 하지만 같은 맥락으로 자바 작성법도 다 잊었는데 그것도 공부해야하나 하는 걱정이 생겼다. 하지만 너무 무리하고 싶진 않다. netwhat 평가나 빨리 받아야겠다....


## 8. 다음 학습 계획

* gnl 구현
* 백준 알고리즘 문제 풀기
* 파이썬 복습
