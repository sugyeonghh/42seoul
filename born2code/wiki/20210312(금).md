

## 1. 학습 날짜

* 2021-03-12(금)



## 2. 학습 시간

* 15:30 ~ (익일)23:30 (자가)



## 3. 학습 범위 및 주제

* cub3D



## 4. 동료 학습 방법

* 디스코드를 통해 어떻게 공부할지, 어떤 자료로 공부할지 공유 (intra ID: yoncho)



## 5. 학습 목표

* cub3D
  * `365kim` 이 올려주신 `lodev.com` 코드 번역 모두 이해하기 (raycasting_tutorial; textured)
  * `yohlee` 의 코드 이해하고 실행시켜보기



## 6. 상세 학습 내용

#### 1. raycasting_tutorial (textured)

```c
 //calculate value of wallX
 double wallX; //where exactly the wall was hit
 if (side == 0) wallX = posY + perpWallDist * rayDirY;
 else           wallX = posX + perpWallDist * rayDirX;
 wallX -= floor((wallX));

```

* wallX 의 값은 벽의 int 형 좌표가 아닌 double 형 좌표로 벽의 정확히 어디에 부딪혔는지 나타냄
  * x면과 부딪혔다면 wallX 의 값은 벽의 x좌표, y면과 부딪혔다면 벽의 y좌표가 된다!



```c
//x coordinate on the texture
int texX = int(wallX * double(texWidth));
if(side == 0 && rayDirX > 0) texX = texWidth - texX - 1;
if(side == 1 && rayDirY < 0) texX = texWidth - texX - 1;
```

* wallX 를 참고하여 texX를 계산



```c
// How much to increase the texture coordinate per screen pixel
double step = 1.0 * texHeight / lineHeight;
// Starting texture coordinate
double texPos = (drawStart - h / 2 + lineHeight / 2) * step;
for(int y = drawStart; y<drawEnd; y++)
{
  // Cast the texture coordinate to integer, and mask with (texHeight - 1) in case of overflow
  int texY = (int)texPos & (texHeight - 1);
  texPos += step;
  Uint32 color = texture[texNum][texHeight * texY + texX];
  //make color darker for y-sides: R, G and B byte each divided through two with a "shift" and an "and"
  if(side == 1) color = (color >> 1) & 8355711;
  buffer[y][x] = color;
}
```

* step: 텍스쳐의 좌표를 수직선 상에 있는 좌표에 대해 얼마나 늘려야 하는지에 따라 결정
* 픽셀의 색상 color -> texture에서 가져옴
* RGB 값을 넣어줄 때 x축과 y축의 색상을 다르게 하기 위해서 y축에 닿으면 `color>>1` (color / 2) 해서 색상을 어둡게 해줌
  * 이때, RGB 의 맨 앞 8비트는 사용하지 않는데, 쉬프트연산을 하게 되면 값 전체가 바뀔 위험이 있기 때문에 첫 번째 8비트는 0이고, 모든 바이트의 첫 번째 비트가 0인 수 `00000000 01111111 01111111 01111111` (10진수로 `8355711` ) 로 AND 연산을 해줘야 한다. 



```c
//swap texture X/Y since they'll be used as vertical stripes
for(size_t i = 0; i < 8; i++)
  for(size_t x = 0; x < texSize; x++)
    for(size_t y = 0; y < x; y++)
			std::swap(texture[i][texSize * y + x], texture[i][texSize * x + y]);
```

* 이미지는 수평선 단위로 저장되지만, 레이캐스터는 텍스처가 수직선으로 그려기지 때문에 텍스쳐도 수평선이 아니라 수직선으로 저장하는 것이 효과적이다. 때문에 x와 y를 바꿔주는 것이 좋다.



<hr>

#### 2. `yohlee` 님 코드 이해하고 실행

* 이 코드는 `lode` 의 코드가 `c++` 로 작성되어있기 때문에 `c` 로 바꾸고 `42 과제 포맷` 에 맞춰서 작성한 코드이다. 따라서 코드를 자세하게 보진 않았다.

* untextured

  <img width="752" alt="스크린샷 2021-03-13 오전 12 50 37" src="https://user-images.githubusercontent.com/55546817/110964079-242a0a00-8396-11eb-9786-aa5160ffaeb0.png">

* textured

  <img width="752" alt="스크린샷 2021-03-13 오전 12 48 52" src="https://user-images.githubusercontent.com/55546817/110963913-fb097980-8395-11eb-9ae7-f18cc0b825b3.png">



## 7. 학습 내용에 대한 개인적인 총평

* 원래 오늘의 목표는 내가 직접 코드를 작성해서 맵을 만든 후에 움직여보는 것이였는데 그것까진 못해봤다. 그리고 내가 공부했던 튜토리얼 코드에서는 맵을 `main` 함수에서 직접 작성해서 구현하는데 실제로는 `--save` 옵션이 있어서 `.bmp` 파일로 입력된 파일을 읽어서 파싱해야한다고 해서 내일은 그것부터 할 예정이다. 오늘 유튜브를 보고 레이캐스팅을 따라할라고 했지만 어떤 블로그를 보니까 42에서 구현해야 하는 것과 좀 다른 부분이 있어서 한계가 있다고 했다. 그래서 내일은 일단 맵 파싱하는 것 부터 먼저 하고 부지런히 따라가야겠다.



## 8. 다음 학습 계획

* cub3D 
  * map parsing

