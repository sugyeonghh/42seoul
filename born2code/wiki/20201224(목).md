## 1. 학습 날짜

2020-12-24(목)


## 2. 학습 시간

* 15:30 ~ 19:40 (자가)
* 20:30 ~ (익일)03:30 (자가)


## 3. 학습 범위 및 주제

* libft 과제
    * ft_memmove.c
    * ft_substr.c
    * ft_subjoin.c
    * ft_subtrim.c
    * ft_itoa.c
    * unit-test
        * ft_memcpy.c
        * ft_strnstr.c

## 4. 동료 학습 방법

* 디스코드 및 슬랙을 통해 unit_test하는 방법 공유 및 테스트 실행 (intra ID: jji, jiwchoi)
* 디스코드 및 슬랙을 통해 ft_memmove 함수와 ft_strtrim 함수 수정
* 디스코드를 통해 ft_memmove 함수 구현 설명 질문 및 unit_test를 위해 필요한 기본 세팅 질문 (헤더파일, Makefile 등) (intra ID: eunjikim)


## 5. 학습 목표

* unit-test 실행 후 오류 수정
* part1 마무리
* part2 작성하기

## 6. 상세 학습 내용
#### 1. ft_memmove.c
* memmove
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `void bzero(void *s, size_t n);`
    * DESCRIPTION
        * The memmove() function copies len bytes from string src to string dst. The two strings may overlap; the copy is always done in a non-destructive manner.
    * RETURN VALUES
        * The memmove() function returns the original value of dst.

* ft_memmove
    * dst와 src가 모두 (NULL)이거나, dst와 src가 같은 문자열이면 (NULL 포인터) 반환
    * memcpy 함수와 비슷하지만, memmove 함수는 dst와 src가 overlap 되는 상황을 고려한다는 것이 다름 
    * 만약, 복사할 문자열인 src의 위치가 복사될 문자열 dst의 위치보다 앞에 위치한다면 원래 복사하고자 하던 문자열(src)이 변경되어 완전히 다른 값을 복사하는 경우가 생기는 데, 이것이 overlap 이다.
        ```
        (example)
        
        // overlap을 고려하지 않는 함수 memcpy
        src[] = "hello world";
        printf("memcpy result: %s ", memcpy(src + 2, src, 5));  // memcpy result: hehehehorld
        
        ```
        
        

    * 따라서, src의 위치가 dst의 위치보다 앞에 있다면 (overlap이 발생한다면) 새로운 문자열에 src를 복사한 후, dst에 복사
    * 하지만 해당 함수에서 새로운 메모리를 할당하는 것이 허용되지 않기 때문에, overlap이 발생한다면 문자열 src의 뒤에서부터 값을 복사하여 overlap을 피한다.

        ```
        (example)
        
        // overlap을 고려하는 함수 memmove
        src[] = "hello world";
        printf("memmove result: %s ", memmove(src + 2, src, 5));  // memmove result: hehelloorld
        
        ```
        
        
        
    * 그렇지 않은 경우 (overlap이 발생하지 않은 경우) memcpy() 함수의 반환값을 반환


<hr>

#### 2. ft_substr.c
* ft_substr
    * SYNOPSIS           
        * `char *ft_substr(char const *s, unsigned int start, size_t len);`
    * PARAMETERS
        * The string from which to create the substring.
        * The start index of the substring in the string ’s’. 
        * The maximum length of the substring.
    * DESCRIPTION
        * Allocates (with malloc(3)) and returns a substring from the string ’s’. The substring begins at index ’start’ and is of maximum size ’len’.
    * RETURN VALUES
        * The substring.  NULL if the allocation fails.
    * EXTERNAL FUNCTS
        * malloc

* algorithm
    * 새로운 문자열을 (len)만큼 잘라서 할당하기 때문에, (len + 1) 만큼 할당하고, 할당에 실패하면 (NULL) 반환
    * 문자열 s가 (NULL)이면 (NULL) 반환
    * 만약 자르기 시작하는 인덱스인 start가 문자열 s의 길이보다 크면 아무것도 넣지 않은 채로 새로운 문자열 할당한 후 반환
        * `return (ft_strdup(""));`
    * 문자열의 s의 start인덱스부터 len만큼 새로운 문자열에 복사하는데, 문자열 s의 값이 널이면 중단
    * 마지막에 널 삽입 후 새로 할당한 문자열 반환


<hr>

#### 3. ft_subjoin.c
* ft_subjoin
    * SYNOPSIS           
        * `char *ft_strjoin(char const *s1, char const *s2);`
    * PARAMETERS
        * The prefix string.
        * The suffix string.
    * DESCRIPTION
        * Allocates (with malloc(3)) and returns a new string, which is the result of the concatenation of ’s1’ and ’s2’.
    * RETURN VALUES
        * The new string.  NULL if the allocation fails.
    * EXTERNAL FUNCTS
        * malloc

* algorithm
    * 문자열 s1 혹은 s2 가 널이라면 (NULL) 반환
    * 새로운 문자열을 (s1의 길이 + s2의 길이 + 1)만큼 할당하고, 할당에 실패하면 (NULL) 반환
    * 새로운 문자열에 s1을 먼저 복사한 후, s2를 복사한 후, 마지막에 (NULL)을 붙임
    * 새로 할당한 문자열 반환


<hr>

#### 4. ft_strtrim.c
* ft_strtrim
    * SYNOPSIS           
        * `char *ft_strtrim(char const *s1, char const *set);`
    * PARAMETERS
        * The string to be trimmed.
        * The reference set of characters to trim.
    * DESCRIPTION
        * Allocates (with malloc(3)) and returns a copy of ’s1’ with the characters specified in ’set’ removed from the beginning and the end of the string.
    * RETURN VALUES
        * The trimmed string.  NULL if the allocation fails.
    * EXTERNAL FUNCTS
        * malloc

* algorithm
    * s1이 (NULL)이면 (NULL) 반환
    * ft_isset 함수를 작성해서 첫 번째 인자로 들어오는 문자가 두 번째로 인자 들어오는 인자에 있는 지 확인
    ```
    int		ft_isset(char c, char const *set)
    {
        while (*set)
            if (*set++ == c)
                return (1);
        return (0);
    }
    
    ```
    
    
    * 문자열의 처음과 끝에서 set에 있는 문자가 있으면 자르는 함수이기 때문에 (int 형)변수 start, end 를 선언한 후, 각 문자열 s1의 처음과 끝에서 set에 있지 않은 문자열의 인덱스를 저장
    * start 값이 end 값보다 크면 새로운 문자열에 아무것도 넣지 않은 상태로 반환
        * `return (ft_strdup(""));`
    * 그렇지 않으면 (end - start + 2) 만큼 새로운 메모리를 할당한 후, 할당에 실패하면 (NULL)을 반환
    * 새로 할당한 메모리에 문자열 s1의 start 인덱스부터 (end - start + 1)개 만큼 복사
        * 마지막에 (NULL)을 넣은 후 반환


<hr>

#### 5. ft_itoa.c 
* ft_itoa
    * SYNOPSIS           
        * `char *ft_itoa(int n);`
    * PARAMETERS
        * The integer to convert.
    * DESCRIPTION
        * Allocates (with malloc(3)) and returns a string representing the integer received as an argument.
        * Negative numbers must be handled.
    * RETURN VALUES
        * The string representing the integer.  NULL if the allocation fails.
    * EXTERNAL FUNCTS
        * malloc

* algorithm
    * (int)형 최소값을 처리하기 위해서 (long long)자료형 변수를 선언하여 인자로 들어온 n을 저장
    * ft_size 함수를 작성하여 숫자의 자리수를 세어 그 반환 값 만큼 새로운 문자열을 할당
        * 만약 n이 음수이면 문자열 처음에 '-'를 넣어주어야 하므로 한 개만큼 더 할당
    * n이 음수이면 새로 할당한 메모리의 처음 값에 '-'를 넣어준 후 (-1)을 곱해서 양수로 만들어줌
    * 나머지 숫자를 문자열에 복사 후 할당한 문자열 반환


<hr>

#### 6. unit-test
1. ##### ft_memcpy
    * memcpy 함수는 n에 관한 예외처리를 해주지 않아도 되기 때문에 해당 예외처리 삭제


2. ##### ft_strnstr
    * 반환 값이 (char * )인데, 인자로 들어오는 자료형은 (const char * )이기 때문에 반환할 때 (char * )

이외 모든 함수 unit-test 실행 후 수정

## 7. 학습 내용에 대한 개인적인 총평
* 생각보다 unit-test 실행 후 생기는 오류가 너무 많아서 오류 수정하는 데에만 하루를 다 쏟았다. 그 과정에서 진이 다 빠졌고 오류 수정에 급급해서 다른 함수를 작성하지 못했고, 너무 오래 걸렸다는 생각에 자신감이 하락했다. 메모리 관련 함수가 쉽다고 생각했지만 관련 오류가 너무 많았고, 어떤 함수는 모든 코드를 갈아 엎어야 할 정도였다. 함수를 하나씩 작성하고 테스트했어야 했는데 너무 늦게 unit-test를 했다는 게 아쉬웠다.
* 그래도 unit-test를 실행한 것이 너무 신기했다. unit-test 오류를 고치느라 war-machine은 실행도 못해봤지만, 내일은 꼭 실행해야겠다.
* strtrim 함수도 구현하는데 꽤 오래걸렸는데, PDF 를 해석하는 것도 오래걸렸고, 함수의 길이가 25줄이 넘어서 norminette에 걸려서 수정하는데 시간이 오래걸렸다. 결국 코드를 새로 작성해서 중간에 포기할 뻔 했지만 동료학습으로 끝까지 해결할 수 있었다.

## 8. 다음 학습 계획
* unit-test 와 war-machine 두 개 모두 실행해보기
* part2 마무리 후 bonus part 작성
* ft_strtrim 함수 수정
* ft_split 작성


