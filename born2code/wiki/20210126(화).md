## 1. 학습 날짜

2021-01-26(화)


## 2. 학습 시간

* 16:00 ~ 19:30 (자가)
* 20:30 ~ (익일) 02:30 (자가)


## 3. 학습 범위 및 주제

* get_next_line

## 4. 동료 학습 방법

* 디스코드를 통해 수정 사항 도움 (intra ID: jji, jiwchoi)

## 5. 학습 목표

* get_next_line 구현

## 6. 상세 학습 내용

#### 1. get_next_line()

* 문제점
	* 버퍼에 새로 읽어들인 것이 없을 때 무조건 종료됨
	* 버퍼에 새로 읽어들인 것이 없더라도 save에 저장된 것이 있다면 save를 기준으로 한 줄을 line 에 붙여야한다.

* 코드

while ((rd_size = read(fd, buf, BUFFER_SIZE)) > 0)
{
	buf[rd_size] = 0;
	if (!save)
		save = ft_strdup(buf);
	else
		save = ft_strjoin(save, buf);
	if ((is_sep = ft_separate(line, &save)))
		return (is_sep);
}
return (ft_separate(line, &save)); // 수정

* 몇 시간을 고민 끝에 위처럼 while 문에 들어가지 못할 경우 return 을 바꿔줬는데 여전히 틀렸다.
* 끝까지 고민하다가 결국 다른 사람 코드를 찾아봤는데 내가 원하는 출력과 다른 모습을 보인 것을 보고 내가 gnl을 잘못 이해해서 잘못 구현했다는 것을 알았다.

<hr>

#### 2. ft_separate()

* 수정 전
	* PROTOTYPE
		* int ft_separate(char **line, char **save, char *tmp)
	* save 와 buf를 저장한 tmp 를 함수의 인자 값으로 받아와서 ft_separate()를 호출하고 get_next_line() 함수에서 free(tmp)를 했었다.

* 수정 후
	* PROTOTYPE
		* int ft_separate(char **line, char **save)
	* buf와 기존에 저장되어 있던 save를 붙여서 save 에 저장한 후 ft_separate()의 인자로 받아온다.
	* ft_separate() 함수에서 tmp 라는 임시 포인터변수를 선언해서 save 값을 저장헤주고 함수 내에서 free(tmp)를 한다.

	

## 7. 학습 내용에 대한 개인적인 총평

* 몇 시간을 수정하고 고민했는데 결국 해결하지 못했다. 너무 화가나고 힘들고 지치고 눈물이 날 것 같은데 꾹 참고 고민했다. 포기하기 직전에 다른 사람 코드를 가져와서 테스트를 해봤을때 내가 원하는 출력과 다른 것을 보고 이 사람이 잘못했나 싶었는데 그럴리가 없었다. 결국 나는 gnl을 잘못 알고있어서 잘못 구현했던 것이고, 이걸 알고 너무 황당하고 어이가 없었다. 오늘은 도저히 못할 것 같아서 그만하기로 했다. 그래서 내일 다시 수정해야 한다.....
* 읽어들일 파일에 빈 줄이 있을 경우에 빈 줄을 제외하고 line에 연결해주는 건줄 알았는데 그게 아니고 정말 파일에 있는 것과 똑같이 나오도록 구현하는 것이였다. gnl pdf에 description 에 한 줄을 읽어서 line에 붙이되 개행을 제외하고 붙이라고 적혀있는데 나는 그게 마지막 개행이 아니고 무조건 개행을 붙이지 말라는 건줄 알았다.... 약간 억울하다(?).


## 8. 다음 학습 계획

* get_next_line() 수정