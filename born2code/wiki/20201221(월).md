## 1. 학습 날짜

2020-12-21(월)


## 2. 학습 시간

10:30 ~ 19:00 (자가)


## 3. 학습 범위 및 주제

* libft 과제
    * Makefile
    * libft.h
    * ft_putchar_fd.c
    * ft_putstr_fd.c
    * ft_putendl_fd.c
    * ft_putnbr_fd.c
    * ft_strlen.c
    * ft_strlcpy.c


## 4. 동료 학습 방법

* 디스코드 및 슬랙을 통해 Makefile 사용의 필요성 및 규칙 학습 (intra ID: jji)
* 디스코드 및 음성 전화를 통해 과제 제출 방법 숙지 및 Makefile을 사용하는 방법과 작성하는 방법 학습 (intra ID: eunjikim)
* 슬랙 및 메신저를 통해 libft과제로 작성할 함수 분석 및 공유 (intra ID: jiwchoi)


## 5. 학습 목표

* 과제 제출 방법과 동료 학습 방법을 숙지한다.
* libft 과제를 위한 함수들을 살펴보고 다섯 개 이상 작성한다.
* Makefile 사용의 필요성을 알고, Makefile의 작성 방법을 학습한다.
* 헤더파일 작성 방법을 학습하고 작성한다.


## 6. 상세 학습 내용

#### 1. Makefile

* 규칙
    * target: 빌드의 결과로 만들고자 하는 (목적)파일
    * dependencies: 타겟을 만들기 위해 필요한 파일들(의존성)
    * command: 타켓을 빌드하기 위한 bash 명령어



* 매크로        
    * 상수 선언, 대문자로 하는 것이 관습
    * NAME: library name
    * SRCS: source files
    * OBJS: object files
    * CC: c compiler
    * CFLAGS: c compile flags
    * RM: remove


    
* .PHONY
    * 더미 타겟과 같은 이름의 파일이 존재할 때 make가 이미 빌드를 끝냈다고 판단하여 해당 더미 타겟의 명령어를 수행하지 않을 때 .PHONY 구문으로 정의하여 방지할 수 있음
    * ex) .PHONY all clean fclean re


* make
    * Makefile에 정의된 규칙들 중 한 개의 타겟을 실행
    * make (타켓을 명시하지 않는 경우 가장 위에 정의된 타겟 실행)
    * make (target)


<hr>

#### 2. libft.h

* 문법
```
#ifndef LIBFT_H     # LIBFT_H 가 선언되지 않았으면
# define LIBFT_H    # LIBFT_H 를 아래와 같이 정의  
...                 # 사용할 헤더 혹은 함수의 프로토타입 명시     
#endif              # 종료
```


<hr>

#### 3. ft_putchar_fd.c

* LIBRARY
    * `#include <unistd.h>`
* SYNOPSIS
    * `void ft_putchar_fd(char c, int fd)`   
* DESCRIPTION
    * Outputs the character ’c’ to the given file descriptor.

* fd가 -1이 아니면(file open 성공시) fd에 문자 c 작성


<hr>

#### 4. ft_putstr_fd.c

* LIBRARY
    * `#include <unistd.h>`
* SYNOPSIS
    * `void ft_putstr_fd(char *s, int fd)`
* DESCRIPTION
    * Outputs the string ’s’ to the given file descriptor.

* fd가 -1이 아니고(file open 성공시) 문자열 s가 NULL이 아니면 fd에 문자열 s 작성


<hr>

#### 5. ft_putendl_fd.c

* LIBRARY
    * `#include <unistd.h>`
* SYNOPSIS
    * `void ft_putendl_fd(char *s, int fd)`
* DESCRIPTION
    * Outputs the string ’s’ to the given file descriptor, followed by a newline.

* fd가 -1이 아니고(file open 성공시) 문자열 s가 NULL이 아니면 fd에 문자열 s 작성 후 마지막에 개행문자 삽입


<hr>

#### 6. ft_putnbr_fd.c

* LIBRARY
    * `#include <unistd.h>`
* SYNOPSIS
    * `void ft_putnbr_fd(int n, int fd)`
* DESCRIPTION
    * Outputs the integer ’n’ to the given file descriptor.

* fd가 -1이면(file open 실패시) 종료
* n이 integer 최소값이면 고정값(최소값) 출력 후 종료
* n이 음수이면 (-1)을 곱함
* n이 9보다 크면 ft_putnbr_fd(n / 10, fd)호출(재귀) 후 fd에 나머지 값 작성
* n이 9보다 작으면 fd에 해당 값 작성


<hr>

#### 7. ft_strlen.c

* strlen
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `size_t strlen(const char *s);`
    * DESCRIPTION
        * The strlen() function computes the length of the string s. The strnlen() function attempts to compute the length of s, but never scans beyond the first maxlen bytes of s.
    * RETURN VALUES

* ft_strlen
    * 문자열 s를 인덱스 i 로 접근
    * 문자열 s의 i번째 값이 NULL일때까지 인덱스 i 증가
    * i 값 반환


<hr>

#### 8. ft_strlcpy.c

* strlcpy
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `size_t strlcpy(char * restrict dst, const char * restrict src, size_t dstsize);`
    * DESCRIPTION    
        * The strlcpy() and strlcat() functions copy and concatenate strings with the same input parameters and output result as snprintf(3). They are designed to be safer, more consistent, and less error prone replacements for the easily misused functions strncpy(3) and strncat(3).
        * strlcpy() copies up to dstsize - 1 characters from the string src to dst, NUL-terminating the result if dstsize is not 0.
    * RETURN VALUES
        * the strlcpy() and strlcat() functions return the total length of the string they tried to create.  For strlcpy() that means the length of src.
     
 * ft_strlcpy
     * dst와 src가 NULL이면 NULL 반환
     * dstsize가 0이 아닐때, dst에 src를 (dstsize - 1)만큼 복사 후 마지막에 NULL 삽입
     * src의 길이 반환


## 7. 학습 내용에 대한 개인적인 총평

* piscine 때 작성했던 함수들이 많이 보여서 첫 날은 무난하게 코딩할 수 있을 것이라 생각했지만 자만이였다. 코딩 외의 환경들을 세팅하는 것 조차 어려워서 오래걸렸다. PDF를 읽는 것부터 오래걸렸고, ssh에 접속하는 것도 힘들었다. 힘겹게 코딩을 시작했는데, 자주 접했던 함수들도 모두 프로토타입을 바꿔서 새로이 작성했어야 했어서 다시 공부를 했다. 크게 힘들진 않았지만, 프로토타입으로 인해 새로 접하게 된 (size_t), (const), (void * )를 공부해야 했다. 평소에 쓰지 않는 것들이 많아서 이런 작은 것들에 시간을 더 쓰게 되었다. 그동안 얼마나 한정된 코딩을 했었는지 알게 되었다. 또, 지난 piscine 때 공부하지 못한 Makefile 과 헤더파일을 작성해야만 libft과제를 통과할 수 있기 때문에 많은 부담이 됐다. Makefile과 헤더는 충분한 시간을 가지고 공부해야겠다고 생각했다.
* 첫 날이라 여러모로 부담도 되고 걱정도 많았지만 클러스터에 나가지 않았다는 거에 비해서 동료학습도 잘 했고, 첫 과제 무난하게 시작한 것 같다. 다만, 클러스터에 나갔다면 아무나 붙잡고 물어봐서 금방 해결했을 수도 있었을 문제가 꽤 많아 시간이 아깝긴 했다. 첫 날은 반은 성공했다고 보고 내일부터도 무난하게, 하지만 더 열심히 과제를 진행할 수 있도록 마음가짐을 잘 해야겠다. 내일부터는 더욱 적극적으로 동료학습을 해야겠다. 



## 8. 다음 학습 계획

* ft_strlcpy.c 함수 수정
* piscine에서 학습했던 함수들을 복습 및 응용하여 libft 과제에 적용하여 작성
* memory 구조와 memory함수 이해 및 작성


