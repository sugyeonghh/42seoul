## 1. 학습 날짜

2021-01-23(토)


## 2. 학습 시간

* 17:00 ~ 22:00 (자가)


## 3. 학습 범위 및 주제

* 백준 알고리즘

## 4. 동료 학습 방법

* 카카오톡을 통해 메모리 초과 원인 및 해결법 논의 (intra ID: yoncho)

## 5. 학습 목표

* 백준 알고리즘 문제
	* 10989 수 정렬하기 3
		* 계수정렬 (counting sort)

## 6. 상세 학습 내용

#### 1. 10989 수 정렬하기 3 - 계수정렬 (counting sort)
* 문제
	* N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.

* 입력
	* 첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.

* 출력
	* 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

* 계수정렬 (counting sort)
	* 배열에 있는 요소의 개수를 세서 그 누적합으로 정렬을 하는 알고리즘
	* 시간복잡도 O(n)

* 알고리즘 - 계수정렬
	* 변수
		* N: 입력받을 N
		* nums: 입력받은 숫자를 저장할 배열
		* cnt: 배열의 요소가 몇 번 나타나는지 저장할 배열, (배열 요소의 최댓값 + 1) 만큼의 길이를 가진다.
		* max: 최댓값을 구하기 위한 변수
		* sorted: 정렬된 배열을 저장할 배열
	
	* N 개 만큼의 수를 입력받아서 저장하고, 그 중의 최댓값을 구하여 max에 저장 후 (max + 1) 만큼 배열 cnt 를 할당한다.
	* 요소의 값의 개수를 cnt 인덱스에 맞춰 저장한다.
		* ex) 배열의 요소 1이 두 개이면 -> cnt[1] = 2
	* 저장된 수를 바탕으로 누적합으로 바꿔준다
		* ex) cnt: [1, 0, 1, 3, 1] -> [1, 1, 2, 5, 6] 
	* 누적합을 바탕으로 nums의 마지막에서부터 위치를 지정해준다.
	```
	sorted[--c[nums[i]]] = nums[i]
	```

	* 코드
```
// 각 요소의 개수 구하기
for (int i = 0; i < N; i++)
	cnt[nums[i]]++;
// 누적합 구하기
for (int i = 1; i < max + 1; i++)
	cnt[i] += cnt[i - 1];
// 정렬된 수를 저장할 배열의 적절한 위치에 요소 값 넣기
for (int i = N - 1; i >= 0; i--)
	sorted[--cnt[nums[i]]] = nums[i];
```



## 7. 학습 내용에 대한 개인적인 총평

* 계수정렬을 오늘 처음 코딩한 것 같다. 원래는 있다는 건 알았지만 학교에서 크게 다루지 않았기 때문에 공부하지 않았었다. 그래서 오늘 처음 공부했는데 아직도 많이 부족하다고 느낀다. 취업할때는 알고리즘을 더 많이 아는 것이 도움이 될텐데 너무 선택적으로 공부한 것이 아닐까 하는 생각이 든다. 42를 할수록 반성을 많이 하게되는 것 같다. 하지만 반성을 한다고해서 내가 바로 공부를 하나? 그건 또 아니다... 그래서 더 반성이 된다.. 그래도 오늘이라도 계수정렬을 공부했으니 남는 것이 있다고 생각한다. 
* 계수정렬을 공부하고 백준 문제를 풀었는데 분명 구현은 완벽하다 생각했는데 메모리 초과로 통과하지 못했다. 도대체 어디가 문제인지, 어디를 어떻게 줄여야할지는 잘 모르겠다. 감이 오지 않는다.. yoncho 에게 물어봤지만 오늘은 결국 해결하지 못했다. 내일은 다른 친구들한테라도 물어봐서 해결해야 겠다. 



## 8. 다음 학습 계획

* 백준 알고리즘 문제 풀기
* gnl