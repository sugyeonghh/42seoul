## 1. 학습 날짜

2021-01-24(일)


## 2. 학습 시간

* 16:00 ~ 20:00 (자가)


## 3. 학습 범위 및 주제

* 백준 알고리즘

## 4. 동료 학습 방법

* 해당 사항 없음

## 5. 학습 목표

* 백준 알고리즘 문제
	* 1427 소트인사이드
	* 11650 좌표 정렬하기 - 수정
	* 15649 N과 M(1) (백트래킹)

## 6. 상세 학습 내용

#### 1. 1427 소트인사이드
* 문제
	* 배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.

* 입력
	* 첫째 줄에 정렬하고자하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.

* 출력
	* 첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.

* 버블 정렬
	* 배열의 전체를 탐색하면서 양 옆의 요소를 비교해서 위치를 바꿔줌
	* 시간복잡도 O(n^2)

* 알고리즘 - 버블 정렬
	* 변수
		* N: 입력받을 N
		* tmp: N 값을 임시로 저장할 변수
		* nums: N의 자리수만큼의 길이를 가지는 배열을 가리키는 포인터변수
		* len: N의 자리수를 저장할 변수
	
	* N을 입력받아서 저장하고, N의 자리수를 계산하여 len에 저장 후, len 만큼의 길이로 배열을 할당한다.
	```
	tmp = N;
	while (tmp)
	{
		tmp /= 10;
		len++;
	}
	nums = (int *)malloc(sizeof(int) * len);
	```

	* 할당된 배열에 N의 각 자리수 값을 저장한 후, 버블 정렬을 사용해서 배열 요소 값을 정렬한다.
	* 코드
	```
	for (int i = len - 1; i > 0; i--)
	{
		for (int j = 0; j < i; j++)
		{
			if (nums[j] < nums[j + 1])
			{
				tmp = nums[j];
				nums[j] = nums[j + 1];
				nums[j + 1] = tmp;
			}
		}
	}
	```

#### 2. 11650 좌표 정렬하기 - 수정
* 문제 
	* 2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.

* 수정 사항
	* 버블정렬을 잘못 구현한 줄 알고 수정하려고 했는데, 아예 for문을 한번만 작성해서 애초에 정렬이 제대로 되지 않았음을 확인했다. 버블정렬 형식으로 알맞게 다시 고쳐주었다.

#### 3. 15649 N과 M(1) (백트래킹)
* 백트래킹: 모든 경우를 탐색하는 알고리즘 
* 백트래킹, 브루트 포스, DFS
	* 백트래킹(역추적)
		* 이미 지나쳐온 곳을 다시 돌아가서 다른 가능성을 시도하는 것을 반복
		* DFS에 가지치기를 이용해 시간복잡도를 줄이는 방법이라고 설명할 수 있음
		* 최적보다 나빠지면 더이상 탐색하지 않음.
	* 브루트 포스
		* 모든 경우의 수를 다 대입해보는 것
	* DFS(완전 탐색)
		* 여러 지점을 한 단계씩 거쳐가면서 탐색, 스택의 개념을 사용해서 이전 단계로 돌아가야함.
		* 가능성이 없는 곳이더라도 탐색할 수 있으므로 효율성이 떨어질 수 있음.


## 7. 학습 내용에 대한 개인적인 총평

* 버블 정렬이 가장 쉬워서 당연하게 잘 알고있다고 생각했는데, 오늘 책을 펴서 다시 살펴보니까 그동안 버블 정렬이랍시고 구현했던 것들을 잘못 구현해왔음을 알게되었다. 갑자기 회의감이 밀려오면서 정말 아무것도 제대로 할 줄 아는게 없다는 생각이 들어서 우울해졌다. 바로 다시 공부하고 어디가 틀렸는지 확실히 집고 넘어갔다.
* 내가 가장 구현하기 좋아하는 정렬 알고리즘은 선택 정렬인데, 그 때문에 버블정렬을 구현하는 것에 헷갈렸나보다. 하나만 잘해도 괜찮다고 생각했는데, 이렇게 기본적이고 가장 쉬운 알고리즘 구현을 틀리는 것은 좀 심각하다고 판단됐다. 날을 잡고 알고리즘을 전체적으로 다시 공부해야겠다.



## 8. 다음 학습 계획

* 백준 알고리즘 문제 풀기
* gnl