## 1. 학습 날짜

2020-12-23(수)


## 2. 학습 시간

10:00 ~ 17:00 (자가)


## 3. 학습 범위 및 주제

* libft 과제
    * ft_memset.c
    * ft_bzero.c
    * ft_memcpy.c
    * ft_memccpy.c
    * ft_memmove.c
    * ft_memchr.c
    * ft_memcmp.c
    * ft_calloc.c (수정)

## 4. 동료 학습 방법

* 디스코드 및 슬랙을 통해 ft_memset, ft_bzero 등 libft 과제에 필요한 메모리 관련 함수 학습 (intra ID: jji, jiwchoi)
* 카카오톡 및 슬랙을 통해 포인터와 이중포인터의 사용 이유 및 방법을 예를 들어 정확하게 학습 (intra ID: jiwchoi, dongilee)
* 음성 전화를 통해 libft 과제 unit_test하는 방법 공유 및 ft_putchar_fd 함수 구현 방법 공유 (intra ID: eunjikim)


## 5. 학습 목표

* 메모리 관련 함수(memset, bzero 등)의 원형을 이해하고 과제의 요구조건에 맞게 작성한다.
* unit-test를 실행 한 후, 오류를 수정한다.
* part1을 마무리한다.


## 6. 상세 학습 내용
#### 1. ft_memset.c
* memset
    * LIBRARY          
        * `#include <string.h>`
    * SYNOPSIS           
        * `void *memset(void *b, int c, size_t len)`
    * DESCRIPTION            
        * The memset() function writes len bytes of value c (converted to an unsigned char) to the string b.
    * RETURN VALUES          
            The memset() function returns its first argument.


* ft_memset
    * 인자값으로 (void * b)가 들어오기 때문에 (unsigned char)로 형변환 시켜서 저장할 변수 필요
    * 메모리에 바이트 단위로 접근하기 위해 (char)형 필요

        ```
        unsinged char *p;
        p = (unsinged char*)b;
        ```
        
    * p로 메모리에 접근해서 c 값을 넣어준 후, b를 반환

<hr>

#### 2. ft_bzero.c
* bzero
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `void bzero(void *s, size_t n);`
    * DESCRIPTION
         * The bzero() function writes n zeroed bytes to the string s.  If n is zero, bzero() does nothing.

* ft_bzero
    * 인자값으로 (void * s)가 들어오기 때문에, (unsigned char)로 형변환 시켜서 저장할 변수 필요
    * 메모리에 바이트 단위로 접근하기 위해 (char)형 필요
        ```
        unsinged char *p;
        p = (unsinged char*)s;
        ```
        
    * p로 메모리에 접근해서 값 0을 넣어줌


<hr>

#### 3. ft_memcpy.c
* memcpy
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `void memcpy(void *restrict dst, const void *restrict src, size_t n);`
    * DESCRIPTION
         * The memcpy() function copies n bytes from memory area src to memory area dst.  If dst and src overlap, behavior is undefined.  Applications in which dst and src might overlap should use memmove(3) instead.
     * RETURN VALUES
         * The memcpy() function returns the original value of dst.

* ft_memcpy
    * dst와 src가 모두 (NULL)이면 (NULL 포인터) 반환
    * 인자값으로 (void * dst), (void * src)가 들어오기 때문에 자료형(unsigned char * )으로 형변환 해서 저장할 새로운 변수 필요
    * 메모리에 바이트 단위로 접근하기 위해 (char)형 필요
     ```
    unsigned char	*dst_p;
	unsigned char	*src_p;
    dst_p = (unsigned char *)dst;
	src_p = (unsigned char *)src;
    ```
    * dst_p와 src_p로 메모리에 접근해서 dst_p 값에 src_p 값을 n개 만큼 넣어줌
    * src_p의 값이 (NULL) 이면 중단
    * 복사한 결과값 dst를 반환


<hr>

#### 4. ft_memccpy.c
* memcpy
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `void *memccpy(void *restrict dst, const void *restrict src, int c, size_t n);`
    * DESCRIPTION
        * The memccpy() function copies bytes from string src to string dst. If the character c(as converted to an unsigned char) occurs in the string src, the copy stops and a pointer to the byte after the copy of c in the string dst is returned. Otherwise, n bytes are copied, and a NULL pointer is returned.

* ft_memccpy
    * memcpy와 같지만 문자열 src에 문자 c가 있다면 dst에 복사한 후 그 다음 위치를 반환하는 것이 다름
    * src 값이 (NULL)일때까지 dst에 복사했는데 문자열 src에 문자 c가 없다면 (NULL 포인터) 반환


<hr>

#### 5. ft_memmove.c
* memmove
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `void bzero(void *s, size_t n);`
    * DESCRIPTION
        * The memmove() function copies len bytes from string src to string dst. The two strings may overlap; the copy is always done in a non-destructive manner.
    * RETURN VALUES
        * The memmove() function returns the original value of dst.

* ft_memmove
    * dst와 src가 모두 (NULL)이거나, dst와 src가 같은 문자열이면 (NULL 포인터) 반환
    * memcpy 함수와 비슷하지만, memmove 함수는 dst와 src가 overlap 되는 상황을 고려한다는 것이 다름 
    * 만약, 복사할 문자열인 src의 위치가 복사될 문자열 dst의 위치보다 앞에 위치한다면 원래 복사하고자 하던 문자열(src)이 변경되어 완전히 다른 값을 복사하는 경우가 생기는 데, 이것이 overlap 이다.
        ```
        (example)
        
        src[] = "hello world";
        printf("memcpy result: %s ", memcpy(src + 2, src, 5));  // memcpy result: hehehehorld
        
        ```

    * 따라서, src의 위치가 dst의 위치보다 앞에 있다면 (overlap이 발생한다면) 뒤에서부터 값을 복사하여 overlap을 피한다.

        ```
        (example)
        
        src[] = "hello world";
        printf("memmove result: %s ", memmove(src + 2, src, 5));  // memmove result: hehelloorld
        
        ```
    * 그렇지 않은 경우 (overlap이 발생하지 않은 경우) memcpy() 함수의 반환값을 반환


<hr>

#### 5. ft_memchr.c
* memchr
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `void *memchr(const void *s, int c, size_t n);`
    * DESCRIPTION
        * The memchr() function locates the first occurrence of c (converted to an unsigned char) in string s.
    * RETURN VALUES
        * The memchr() function returns a pointer to the byte located, or NULL if no such byte exists within n bytes.

* ft_memchr
    * 인자값으로 (void * p)가 들어오기 때문에 자료형(unsigned char * )으로 형변환 해서 저장할 새로운 변수 필요
    * 메모리에 바이트 단위로 접근하기 위해 (char)형 필요
     ```
    unsigned char	*p;
    p = (unsigned char *)s;
    ```

    * 문자열 s를 p로 접근하여 (unsigned char)로 형변환 한 c와 비교하는데, 문자열 s의 처음 인덱스부터 n개까지만 비교 한다.
    * 만약 문자열 s에 문자 c가 있다면 해당 위치 반환
    * n개 만큼 비교했는데 문자열 s에서 문자 c를 찾지 못했다면 (NULL) 반환


<hr>

#### 6. ft_memcmp.c
* memcmp
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `int memcmp(const void *s1, const void *s2, size_t n);`
    * DESCRIPTION
        * The memcmp() function compares byte string s1 against byte string s2. Both strings are assumed to be n bytes long.
    * RETURN VALUES
        * The memcmp() function returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that '\200' is greater than '\0', for example). Zero-length strings are always identical. This behavior is not required by C and portable code should only depend on the sign of the returned value.

* ft_memcmp
    * 문자열 s1과 문자열 s2를 n개만큼 비교
    * 인자값으로 (void * dst), (void * src)가 들어오기 때문에 자료형(unsigned char * )으로 형변환 해서 저장할 새로운 변수 필요
    * 메모리에 바이트 단위로 접근하기 위해 (char)형 필요
     ```
    unsigned char	*dst_p;
	unsigned char	*src_p;
    dst_p = (unsigned char *)dst;
	src_p = (unsigned char *)src;
    ```
    * 만약 p1과 p2가 같거나 n이 널이라면 (NULL) 반환
    * p1과 p2가 다르다면 (p1 - p2) 반환


<hr>

#### 7. ft_calloc.c
* ft_calloc (수정)
    * (count * size) 만큼의 길이로 새롭게 할당한 메모리에 값 (0)을 넣은 후 반환
    * 기존 코드는 할당한 메모리에 직접 접근하여 값 (0)을 넣었지만, ft_bzero() 함수를 사용하여 값 (0)을 넣어줌


## 7. 학습 내용에 대한 개인적인 총평
* 오늘은 메모리 관련 함수를 작성하는 데 힘을 썼다. 메모리 관련 함수라 해서 겁부터 먹었는데 막상 코드를 작성해보니 string 함수들이랑 비슷했다. 인자값이 (void * )로 들어온다는 것과 (unsigned char * )로 처리하는 것 정도만 달랐다. 심지어 memory에 있는 값을 비교하거나 복사하는 함수여서 string 함수와 달리 예외처리를 크게 하지 않아도 된다는 것이 오히려 편했다. 지금까지 겁먹은 것이 후회될 정도로 간단했고, 처음에 작성했어야 뒤에 나오는 다른 함수들에서 사용이 용이하다는 것을 알았다. PDF 처음에 나오는 이유가 있다는 것을 나중에서야 깨닳아서 아쉬웠다. 앞으로는 PDF에 명시된 순서대로 작성하도록 노력해야겠다. 
* 메모리 관련 함수가 비교적 쉽게 작성된 것은 맞지만, 그렇다 하더라도 꽤 오랜 시간 걸려서 작성했다. (unsigned char)로 형변환 하는 이유를 공부하느라 오래 걸리기도 했고, memcpy와 memmove의 차이인 overlap 때문에 오래걸렸다. 그래도 오래 붙잡고 있었기 때문에 overlap에 대해 정확하게 공부한 것 같다. 하지만 그것 때문에 unit-test할 시간이 없었다는 것이 아쉬웠다. 내일은 꼭 unit-test를 실행해야겠다.


## 8. 다음 학습 계획

* unit-test 실행 후 오류 수정
* part1 마무리
* part2 작성하기

