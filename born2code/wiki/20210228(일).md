## 1. 학습 날짜

* 2021-02-28(일)



## 2. 학습 시간

* 10:30 ~ 22:30 (개포동 클러스터)



## 3. 학습 범위 및 주제

* cub3D



## 4. 동료 학습 방법

* 클러스터에서 다른 사람의 블로그에 나온 레이캐스팅 학습 (intra ID: yoncho)



## 5. 학습 목표

* cub3D 를 위한 배경지식 학습
  * raycasting - untextured



## 6. 상세 학습 내용

#### 1. raycasting - untextured

* 365kim 님의 github를 참고해서 raycaster 이해 (https://github.com/365kim/raycasting_tutorial/blob/master/3_untextured_raycaster.md)
* 코드 설명
    * 변수
        * posX, posY: 플레이어의 초기 위치벡터
        * dirX, dirY: 플레이어의 초기 방향벡터
        * planeX, planeY: 플레이어의 카메라 평면
            * FOV: `카메라평면의 길이 : 방향벡터의 길이`, 1인칭 시점에 가장 적합한 FOV: 66.8
        * cameraX: for문의 x값이 위치가 카메라 평면에서 차지하는 x좌표
            * 범위 : -1 <= cameraX <= 1
            * -1: 스크린의 왼쪽 끝
            * 0 : 스크린의 중앙
            * 1 : 스크린의 오른쪽 끝
        * rayDirX, rayDirY: 광선의 방향벡터
            * 광선의 방향 = 방향벡터 + (카메라 평면 * 배수)
        * perpWallDist: 광선의 이동거리
    * DDA 알고리즘
        * 반복문을 실행할 때마다 x방향 또는 y방향으로 딱 한 칸씩 점프
        * 변수
            * mapX, mapY: 광선의 위치, 광선이 있는 한 칸
            * sideDistX: 시작점 ~ 첫번째 x면을 만나는 점까지의 광선의 이동거리
                * `rayDirX > 0`
                    * 광선의 시작점부터 오른쪽으로 이동하다가 처음 만나는 x면까지의 거리
                * `rayDirX < 0`
                    * 광선의 시작점부터 왼쪽으로 이동하다가 처음 만나는 x면까지의 거리
            * sideDistY: 시작점 ~ 첫번째 y면을 만나는 점까지의 광선의 이동거리
                * sideDistX와 동일
            * deltaDistX: 첫번째 x면 ~ 바로 다음 x면 까지의 광선의 이동거리
            * dletaDistY: 첫번째 y면 ~ 바로 다음 y면 까지의 관선의 이동거리
            * stepX, stepY: 광선의 방향에 따라 어느 방향으로 거너뛰는지 알려줌, `-1 or 1`
            * hit: 광선이 벽에 부딪혔는지 여부를 알려줌. while 반복문 종료 조건. 
                * `x면에 부딪히면 side = 0`, `y면에 부딪히면 side = 1`
                * side 의 값으로 벽의 x면에 부딪혔는지 y면에 부딪혔는지 알 수 있다. 또, mapX, mapY로 어떤 벽이랑 부딪힌 건지 알 수 있다.
        * 코드
            ```
            //perform DDA
            while (hit == 0)
            {
                //jump to next map square, OR in x-direction, OR in y-direction
                if(sideDistX < sideDistY)
                {
                  sideDistX += deltaDistX;
                  mapX += stepX;
                  side = 0;
                }
                else
                {
                  sideDistY += deltaDistY;
                  mapY += stepY;
                  side = 1;
                }
                //Check if ray has hit a wall
                if(worldMap[mapX][mapY] > 0) hit = 1;
            }
            ```
    * 어안렌즈 효과 (fisheye effect)
        * 실제 거리 값을 사용했을 때 모든 벽이 둥글게 보여서 회전할 때 울렁거리는 현상
        * 실제 거리값을 구하면 벽에 닿는 광선 마다의 길이가 모두 다르기 때문에 벽의 높이가 일정하지 않게 되어 발생한다.
        * 이런 효과를 피하기 위해 카메라 평면까지의 거리를 사용한다.
        * `side = 0`
            * `perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX`
        * `side = 1`
            * `perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY` 


## 7. 학습 내용에 대한 개인적인 총평

* 다른 사람의 코드라서 너무 어렵다. 해설을 길게 풀어서 써놨지만 변수가 많고 내 코드가 아니라서 너무 어렵다. 코드 이해만 하루 종일하고 있는데 원래 `어려운 코드 + 변수 많음` 으로 머리가 터져버린 것 같다. 이해가 안되니까 다른 걸로 넘어갈수도 없고 계속 같은 자리에 머물러 있는 기분이 든다. 클러스터에서 하루종일 코드 분석을 하고 앉아있는데 너무 못해서 멘탈이 터져버렸다... 옆에 `yoncho` 가 없었으면 여기까지도 이해하지 못했을 것 같다. 
* 클러스터에 온게 다행이지만 한편으로는 클러스터에 와도 이정돈데 집에서는 더 못할 것 같다는 생각이 들어서 무섭다... 일주일에 클러스터는 20시간으로 제한되어 있는데 안오는 사람들이 훨씬 많은데.. 그렇게 안해도 될 것 같다,,, 매일매일 클러스터와서 동료랑 함께 문제를 풀고싶다... 하면 할수록 한 달도 넘게 걸릴 것 같다. 

## 8. 다음 학습 계획

* cub3D 기초 지식
  * raycasting 구현 코드 이해
  * https://github.com/365kim/raycasting_tutorial/blob/master/3_untextured_raycaster.md 참고



