## 1. 학습 날짜

2021-01-12(화)


## 2. 학습 시간

* 19:00 ~ 24:00 (자가)


## 3. 학습 범위 및 주제

* 백준 알고리즘
	* 브루트 포스(brute force; 무차별 대입 공격): 모든 경우의 수를 검사
		* 7568 덩치
		* 1018 체스판 다시 칠하기
		* 1436 영화감독 숌
		* 2750 수 정렬하기



## 4. 동료 학습 방법

* 디스코드를 통한 알고리즘 학습 (intra ID: jji, jiwchoi, yoncho)


## 5. 학습 목표

* 백준 (코딩 사이트)에 있는 문제 풀기


## 6. 상세 학습 내용

* 브루트 포스(brute force; 무차별 대입 공격): 모든 경우의 수를 검사해서 결과를 도출하는 알고리즘
#### 1. 7568 덩치
* 문제
	* A의 몸무게와 키가 B의 몸무게와 키보다 클 때, A의 덩치가 더 크다
	* 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.
	* 덩치 등수를 계산하여 출력하라.

* 입력
	* 첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.

* 출력
	* 여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.

* 예제 1
	* 입력
		```
		5
		55 185
		58 183
		88 186
		60 175
		46 155
		```
	
	* 출력 
		```
		2 2 1 2 5
		```

* 알고리즘
	* 변수
		* N: 입력받을 사람 수
		* *weight: 입력받은 몸무게 값을 저장할 배열
		* *high: 입력받은 키 값을 저장할 배열
		* k: 덩치 계산을 위한 변수
		* *res: 최종 덩치 등수 배열
	* N 명의 몸무게와 키를 입력받아와서 각각 배열로 저장한다.
	* for 문을 이중 중첩해서 몸무게와 키가 둘 다 크면 k를 증가시킨다.
	* 최종 저장된 k 를 res 배열에 저장한다.
	* 배열 res를 출력한다.
	* 코드
		```
		for (int i = 0; i < N; i++)
		{
			k = 0;
			for (int j = 0; j < N; j++)
			{
				if (i == j)
					continue;
				if ((weight[i] < weight[j]) && (high[i] < high[j]))
					k++;
			}
			res[i] = k + 1;
		}
		```


<hr>

#### 2. 1018 체스판 다시 칠하기
* 문제
	* (M * N) 크기의 보드를 입력받고 그 안에서 (8 * 8) 크기의 체스판을 찾는다. 보드가 체스판처럼 칠해져 있다는 보장이 없기 때문에 새롭게 칠해야하는데, 다시 칠해야 하는 정사각형의 최소 개수를 구하시오.
	* 체스판의 패턴: WBWB가 교차된 상태

* 입력
	* 첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.

* 출력
	* 첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.

* 예제 1
	* 입력
		```
		8 8
		WBWBWBWB
		BWBWBWBW
		WBWBWBWB
		BWBBBWBW
		WBWBWBWB
		BWBWBWBW
		WBWBWBWB
		BWBWBWBW
		```

	* 출력
		```
		1
		```

* 예제 2
	* 입력
		```
		10 13
		BBBBBBBBWBWBW
		BBBBBBBBBWBWB
		BBBBBBBBWBWBW
		BBBBBBBBBWBWB
		BBBBBBBBWBWBW
		BBBBBBBBBWBWB
		BBBBBBBBWBWBW
		BBBBBBBBBWBWB
		WWWWWWWWWWBWB
		WWWWWWWWWWBWB
		```

	* 출력
		```
		12
		```

* 알고리즘
	* 변수
		* N: 행
		* M: 열
		* start_W = "WBWBWBWB" : W로 시작한 체스 패턴
		* start_B = "BWBWBWBW" : B로 시작한 체스 패턴
		* cnt: 현재 보드에서 다시 칠해야 하는 정사각형의 개수의 최소값
		* res: 모든 경우의 수 중 가장 작은 값
		* (이중포인터)board: 입력받은 보드
	
	* 함수
		* find_arr: 다시 칠해야 하는 정사각형의 최소 개수를 찾는 함수 (W로 시작하거나 B로 시작하는 패턴으로 검사해서 최소값을 도출)
			`find_arr(char **board, int x, int y, char *compare1, char *compare2)`
			* 정해진 패턴과 비교해서 다르면 cnt(지역변수) 증가 후 반환

	* (N * M) 크기의 배열을 입력받아서 board 에 저장 
	* for 문을 이중 중첩으로 사용해서 board 의 처음부터 접근해서 (8 * 8) 체스판을 찾음
		* 체스판이 (N * M) 범위를 넘어가면 함수를 호출하지 않고 넘어감
	 	* W 로 시작하는 체스판과 B 로 시작하는 체스판 두 경우를 모두 계산해서 둘 중 최소값을 cnt 에 저장한 후, 그 값이 최종 값인 res 보다 작으면 res에 cnt를 저장한다
	* 최종 저장된 res 를 출력
	* 코드
		```
		for (int i = 0; i < N; i++)
		{
			cnt = 0;
			for (int j = 0; j < M; j++)
			{
				if ((i + 7 >= N) || (j + 7 >= M))
					continue;
				int W = find_arr(board, i, j, start_W, start_B);
				int B = find_arr(board, i, j, start_B, start_W);
				cnt = W < B ? W : B;
				res = cnt < res ? cnt : res;
			}
		}
		```



<hr>

#### 3. 1436 영화감독 숌
* 문제
	* 종말의 숫자: 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.
	* N 번째 종말의 숫자를 구하시오.

* 입력
	* 첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.

* 출력
	* 첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.

* 예제 1
	* 입력
		```
		2
		```

	* 출력
		```
		1666
		```

* 알고리즘
	* 변수
		* N: 입력받을 N
		* num: 0 부터 증가하면서 N 번째 숫자를 찾을 변수
		* cnt: 몇 번째 종말 숫자인지 확인하는 변수
	
	* 함수
		* is_pattern(int num): 인자로 받아온 num 이 종말 숫자인지 확인하는 함수
			`is_pattern(int num)`
			* 맞으면 1, 아니면 0을 반환
	* 함수에 num 을 넣고 호출한 값이 1이면 (종말 숫자이면) cnt 증가
	* 해당 숫자가 N번째 숫자이면 그 숫자를 출력
	* 코드
		```
		while (1)
		{
			if (cnt == N)
				break ;
			if (is_pattern(num++))
				cnt++;
		}
		printf("%d", num - 1);
		```


<hr>

* 정렬

#### 4. 2750 수 정렬하기
* 문제
	* N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.

* 입력
	* 첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.

* 출력
	* 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

* 예제 1
	* 입력
		```
		5
		5
		2
		3
		4
		1
		```

	* 출력
		```
		1
		2
		3
		4
		5
		```

* 알고리즘
	* 변수
		* N: 숫자의 개수
		* (포인터)nums: 입력받을 값을 저장할 배열 
		* min: 최소값 인덱스
		* tmp: 값을 변경할 때 임시로 저장해둘 변수
	
	* 선택 정렬
		* 배열 값 중 가장 작은 수를 찾아서 맨 앞에 위치시켜 준다
	* 코드
		```
		for (int i = 0; i < N - 1; i++)
		{
			min = i;
			for (int j = i + 1; j < N; j++)
			{
				if (nums[j] < nums[min])
					min = j;
			}
			tmp = nums[i];
			nums[i] = nums[min];
			nums[min] = tmp;
		}
		```


## 7. 학습 내용에 대한 개인적인 총평

* 점점 공부하는 시간대가 늦어지고 있어서 학습 패턴이 꼬이는 것 같다. 일찍 일어나서 하지 않으니까 의지도 많이 꺾이는 것 같고 시간 활용성도 떨어지는 것 같다. 좀 더 계획적으로 공부 계획을 세워서 실천해야겠다. 
* [체스판 다시 칠하기] 문제에서 함수에 (i 값, j 값)을 넘기는데 그걸 잘못 사용한 것을 모르고 있다가 계속 틀려서 오류 찾는 데만 많은 시간이 걸렸다. 괜히 프로토타입에 (x, y)로 썼다가 헷갈렸다. 변수 이름을 더 정확하게 사용해야겠다. 
* 넷왓을 또 미뤄버렸다. 넷왓 공포증이 생길 것 같다. 그런데 내일은 꼭 해서 평가를 받아야겠다. 내일은 평가 풀이 풀린다고 했으니 꼭 마무리해서 넷왓 평가도 받고 평가를 하기도 해야겠다. 



## 8. 다음 학습 계획

* 백준 알고리즘 문제 2개 풀기
* docker 공부
* netwhat
	* What are the rules to make 2 devices communicate using IP addresses
	* How does routing work with IP
	* What is a default gateway for routing
	* What is a port from an IP point of view and what is it used for when connecting to another device
