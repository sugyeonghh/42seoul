## 1. 학습 날짜

2021-01-09(토)


## 2. 학습 시간

* 20:00 ~ (익일)01:30 (자가)


## 3. 학습 범위 및 주제

* 백준 알고리즘
	* 브루트 포스(brute force; 무차별 대입 공격): 모든 경우의 수를 검사
		* 2798 블랙잭
		* 2231 분해합


## 4. 동료 학습 방법

* 디스코드를 통한 알고리즘 학습 (intra ID: jji, jiwchoi, yoncho)

## 5. 학습 목표

* 백준 (코딩 사이트)에 있는 문제 풀기


## 6. 상세 학습 내용

* 브루트 포스(brute force; 무차별 대입 공격): 모든 경우의 수를 검사해서 결과를 도출하는 알고리즘
* 2798 블랙잭
	* 문제
		* N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.
	* 입력
		* 첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.
	* 출력
		* 첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.
	* 예제 1
		* 입력
            ```
			5 21
			5 6 7 8 9
            ```


		* 출력
            ```
			21
            ```
            

	* 예제 2
		* 입력
            ```
			10 500
            ```

		* 출력
            ```
			93 181 245 214 315 36 185 138 216 295
            ```

	* 알고리즘
		* 변수
			* N: 카드의 개수
			* M: 기준 값
			* *card: 카드 값
			* sum: 결과값 (기준 값에 가장 가까운 값)
		* N 장의 카드를 malloc 으로 새롭게 할당해서 입력을 받아온다
		* 총 3장의 카드를 골라서 나올 수 있는 모든 경우의 수를 확인해야한다. for문 3개를 중첩시켜서 인덱스로 접근해서 각 인덱스의 값을 더해서 확인할 수 있다. 이 때, 중복없이 모든 경우의 수를 확인해야 하므로 처음 인덱스 다음 다음 인덱스를 접근해야한다.

			for (int i = 0; i < N - 2; i++)            // i = 0 (처음 인덱스부터 마지막 인덱스 전전까지 접근)
				for (int j = i + 1; j < N - 1; j++)    // j = i + 1 (i 다음 인덱스부터 마지막 인덱스 전까지 접근)
					for (int k = j + 1; k < N; k++)    // k = j + 1 (j 다음 인덱스부터 마지막 인덱스까지 접근)
		
		* 만약 세 카드의 합(세 값의 합)이 M보다 크면 다음 인덱스로 넘어간다.
		* 만약 세 카드의 합이 M보다 작거나 같고, sum보다 크면 해당 값을 저장한다.
		* 마지막으로 저장한 값 sum을 출력 후 종료


<hr>

* 2231 분해합
	* 문제
		* 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다. 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
	* 입력
		* 첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
	* 출력
		* 첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.
	* 예제 1
		* 입력
            ```
            216
            ```
            
		* 출력
			```
            198
            ```
	
	* 알고리즘
		* 변수
			* N: 자연수 N
			* i: 결과값 (0 부터 N 까지 증가하면서 N의 생성자인지 확인)
		* 함수
			* ft_add(): 각 자리수의 합을 더해서 반환
		* i를 0부터 N - 1 까지 반복문 진행
			* 자기 자신(i) + 각 자리수의 합(ft_add(i))이 N과 같으면 break
			* 그렇지 않으면 i 증가
		* 반복문이 끝난 후 최종 값 (자기 자신(i) + 각 자리수의 합(ft_add(i))) 이 N 보다 크다면 N의 생성자가 없다는 뜻이므로 0을 출력
		* 그렇지 않으면 자기 자신(i) 값 출력 후 종료


## 7. 학습 내용에 대한 개인적인 총평

* 네트워크에 도저히 집중을 할 수가 없어서 코딩을 하기로 했다. 본과정 첫 주 이후로 사기가 많이 떨어진 것 같아서 이러지 말고 온라인 코딩 사이트에서 문제를 풀자는 동료의 제안으로 오늘부터 백준 사이트에서 문제를 풀기로 했다. 42 본과정에 집중하는 것도 좋지만, 그거에만 몰두할 게 아니라 일반 알고리즘 문제를 푸는 것도 도움이 될거라 생각했다. 
* 오랜만에 일반 알고리즘 문제를 풀어보니 main 함수 작성하는 것 부터 어색했다. 하지만 netwhat 을 공부하는 것보다 이런 알고리즘 생각하는 것이 더 수월했다. 생각 외로 피씬때 했던 내용이 도움이 됐다. 알고리즘을 구현을 하려는데 그 내용이 떠올라서 바로 적용해서 작성했다. 한 달의 짧은 피씬이 헛 수고가 아니였던 것 같아서 기분이 좋았다.
* 다음주에는 netwhat을 꼭 통과하고 get_next_line 을 해결하고 싶다.



## 8. 다음 학습 계획

* netwhat
	* What are the rules to make 2 devices communicate using IP addresses
	* How does routing work with IP
	* What is a default gateway for routing
	* What is a port from an IP point of view and what is it used for when connecting to another device

