

## 1. 학습 날짜

* 2021-03-25(목)



## 2. 학습 시간

* 12:00 ~ 17:00 (자가)



## 3. 학습 범위 및 주제

* 리눅스 명령어
* 리트코드 알고리즘 풀기



## 4. 동료 학습 방법

* 해당 사항 없음



## 5. 학습 목표

* 리눅스 명령어 학습
* 리트코드 알고리즘 2개 풀기



## 6. 상세 학습 내용

#### 1. 리눅스 명령어 (복습)

* `which` : 명령어의 위치를 알려줌
* `whereis` : 명령어의 위치 + 명령어와 관련된 설정 및 소스파일, man 페이지 파일의 위치 표시
* `df` : 저장장치 및 파일 시스템의 마운트 정보와 사용량 확인
  * `-h` 옵션: 파일 크기를 사람이 읽기 편한 단위 (K, M, G) 로 확인
* `grep` : 파일 내에서 검색어가 있는 행만 화면에 출력

  * `-r` 옵션: 하위 디렉토리까지 검색
  * `-n` 옵션: 검색 결과에 파일 내의 문자열이 위치한 행 번호 출력
* `find` : 설정한 디렉토리부터 하위 디렉토리까지 파일 또는 디렉토리 검색 -> `r` 옵션 x 



<hr>

#### 2. 리트코드 알고리즘 1 - no.1672

Richest Customer Wealth

* 문제

  * example 1

  ```
  Input: accounts = [[1,2,3],[3,2,1]]
  Output: 6
  Explanation:
  1st customer has wealth = 1 + 2 + 3 = 6
  2nd customer has wealth = 3 + 2 + 1 = 6
  Both customers are considered the richest with a wealth of 6 each, so return 6.
  ```

  * example 2

  ```
  Input: accounts = [[1,5],[7,3],[3,5]]
  Output: 10
  Explanation: 
  1st customer has wealth = 6
  2nd customer has wealth = 10 
  3rd customer has wealth = 8
  The 2nd customer is the richest with a wealth of 10.
  ```

  * example 3

  ```
  Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
  Output: 17
  ```

* 알고리즘

  * 제시된 2차원 배열에서 각각의 1차원 배열의 합을 더해 최대값을 구한다.
  * 코드

  ```c
  int maximumWealth(int** accounts, int accountsSize, int* accountsColSize){
  
      int max = 0;
      int sum;
      
      for (int i = 0; i < accountsSize; i++)
      {
          sum = 0;
          for (int j = 0; j < *accountsColSize; j++)
              sum += accounts[i][j];
          if (sum > max)
              max = sum;
      }
      return (max);
  }
  ```



<hr>

#### 3. 리트코드 알고리즘 2 - no.13

Roman to Integer

* 문제

  * 로마 숫자로 된 문자열을 받아서 정수값으로 바꾸는 문제
  * 규칙
    * `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
    * `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
    * `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.
  * example 1

  ```
  Input: s = "III"
  Output: 3
  ```

  * example 2

  ```
  Input: s = "IV"
  Output: 4
  ```

  * example 3

  ```
  Input: s = "IX"
  Output: 9
  ```

  * example 4

  ```
  Input: s = "LVIII"
  Output: 58
  Explanation: L = 50, V= 5, III = 3.
  ```

* 알고리즘

  * 각각 문자에 맞는 값을 상수로 선언 (define)
  * 규칙에 맞게 세 가지 경우를 나눠서 각각 경우에 맞는 수를 더하도록 함
    * `V` or `X` 를 만난 경우, 바로 앞의 문자가 `I` 라면 최종 결과값 result 에 ( `V` or `X` 값 - `I` ) 를 더해줌
    * `L` or `C` 를 만난 경우, 바로 앞의 문자가 `X` 라면 최종 결과값 result 에 ( `L` or `C` 값 - `X` ) 를 더해줌
    * `D` or `M` 를 만난 경우, 바로 앞의 문자가 `C` 라면 최종 결과값 result 에 ( `D` or `M` 값 - `C` ) 를 더해줌

  * 코드

  ```c
  #define I 1
  #define V 5
  #define X 10
  #define L 50
  #define C 100
  #define D 500
  #define M 1000
  
  
  int romanToInt(char *s){
      
      int     result = 0;
      int     num = 0;
      
      for (int i = 0; i < strlen(s); i++){
          if (s[i] == 'I')
              result += I;
          if (s[i] == 'V' || s[i] == 'X'){
              num = (s[i] == 'V') ? V : X;
              if (i > 0 && s[i - 1] == 'I')
                  result += num - I * 2;
              else
                  result += num;
          }
          else if (s[i] == 'L' || s[i] == 'C'){
              num = (s[i] == 'L') ? L : C;
              if (i > 0 && s[i - 1] == 'X')
                  result += num - X * 2;
              else
                  result += num;
          }
          else if (s[i] == 'D' || s[i] == 'M'){
              num = (s[i] == 'D') ? D : M;
              if (i > 0 && s[i - 1] == 'C')
                  result += num - C * 2;
              else
                  result += num;
          }
      }
      return (result);
  }
  ```

  



## 7. 학습 내용에 대한 개인적인 총평

* 리트코드 문제 13번을 푸는데 처음엔 `if` , `else if` 문을 사용해서 경우를 나눠서 작성했다. 근데 틀린 답이 나와서 보니까 조건문을 원하는 방식으로 돌아가지 않게 중복되게 작성해서 원하는 답이 나오지 않았다. 이 과정을 꽤 오래 수정한 후에 다시 돌렸는데 런타임 에러가 발생했다. 오답이라도 나오던 코드가 에러가 발생하니까 너무 당황스러웠다. 
* 처음에는 `while` 문으로 돌리면서 문자열 `s` 에 직접 접근해서 포인터 위치를 이동시키면서 위 규칙처럼 `V, X, L, C, D, M` 을 만나면 그 앞에 있는 문자가 `I, X, C` 인지 확인한 후에 맞는 연산을 하도록 했다. 그런데 맨 처음에 문자열 `s` 의 원래위치에서 `s-1` 위치에 접근하는 것에서 오류가 발생하는 것을 알아냈다. 그래서 포인터로 접근해서 해결할 수 없어서 `for` 문으로 바꿔서 각각 인덱스에 접근하도록 했고, `0` 인덱스라면 그 전에 있는 문자를 확인하지 않도록 고치니까 통과되었다.
* 오늘 두 가지 오류를 고치는데만 한 시간은 걸린 것 같다. 너무 속상했다. 솔직히 쉬운 문제들이였는데 이런 문제들을 이렇게 오래 걸려서 푼다는 것 자체가 4년의 기간을 의미없게 만드는 것 같아서 마음이 안좋았다. 개발자가 길이 아니라는 생각이 다시 들었다...... ㅠ...... 그래서 오늘은 우울하다.

 

## 8. 다음 학습 계획

* 정보처리기사 실기시험 공부
* cub3D

