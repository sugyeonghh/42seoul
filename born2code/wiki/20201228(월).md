## 1. 학습 날짜

2020-12-28(월)


## 2. 학습 시간

* 13:30 ~ 20:40 (자가)
* 21:40 ~ (익일)02:00 (자가)


## 3. 학습 범위 및 주제

* libft 과제
    * ft_split
    * ft_itoa (수정)
    * Makefile

## 4. 동료 학습 방법

* 디스코드를 통해 ft_split 함수 구현 도움 (intra ID: jiwchoi, jji, chaeekim, namhkim)
* 디스코드를 통해 Makefile 문법과 그 의미 학습 (intra ID: jiwchoi, jji)


## 5. 학습 목표

* ft_split 함수 작성
* Makefile 공부 후 새로 작성
* 모든 함수 unit-test, war-machine 테스트 후 오류 처리
* norminette 테스트
* VNC로 과제 제출하는 git에 push


## 6. 상세 학습 내용

#### 1. ft_itoa (수정)
* ft_itoa
    * 서브함수의 반환 자료형 앞에 static을 붙여야함 -> 서브함수 ft_size의 반환 자료형 앞에 (static) 작성


<hr>

#### 2. ft_split.c
* ft_split
    * SYNOPSIS           
        * `char **ft_split(char const *s, char c);`
    * DESCRIPTION
        * Allocates (with malloc(3)) and returns an array of strings obtained by splitting ’s’ using the character ’c’ as a delimiter. The array must be ended by a NULL pointer.
    * RETURN VALUES
        * The array of new strings resulting from the split. NULL if the allocation fails.
    * EXTERNAL FUNCTS
        * malloc, free

* algorithm
    * ft_word_count(): 총 단어의 개수를 세는 함수
        * 문자열 s의 주소와 문자 c(split 기준 문자)를 인자값으로 받아옴
        * 단어의 개수를 세는 변수 cnt 선언, 0으로 초기화
        * 포인터로 문자열에 접근해서 문자열 값이 문자 c와 같다면 넘겨줌 (단어가 아니기 때문)
        * 문자열 s 값이 문자 c가 아니라면(기준 문자가 아니라면) cnt 증가
        * 문자열 s 값이 문자 c를 만날때까지 포인터 s를 증가시켜줌 (단어의 길이가 1이 아닐때 고려)
        
        ```
        while (*s)
        {
            while (*s && *s == c)
                s++;
            if (*s)
                cnt++;
            while (*s && *s != c)
                s++;
        }
        ```
        
        
        
        * 단어의 개수 (cnt) 반환

    * ft_free(): 메모리 할당 실패 시 할당했던 모든 메모리 free 하는 함수
        * free 할 메모리 주소를 받아옴 (char * * )
        * 배열에 접근해서 해당 배열의 값을 free
        * 배열 free

        ```
        i = 0
        while (res[i])
            free(res[i++]);
        free(res);
        ```
        
        
        * ft_split() 함수에서 return (ft_free())로 사용해서 종료하기 위해 ft_split()의 반환 자료형인 (char * * )로 작성함

    * ft_split()
        * 만약 문자열 s가 (NULL)이면 (NULL) 반환
        * 새로 만들어서 반환할 문자열을 가리지는 포인터 변수 res선언 후 (ft_word_count() 의 반환값(단어의 개수) + 1)만큼 (char * )형 메모리 할당 후 할당에 실패하면 (NULL)반환
            * 각 배열이 문자열을 가리킬수 있도록 (char * )형으로 할당        
            ```
            res = malloc(sizeof(char *) * (ft_word_count(s, c) + 1))
            ```
            
            
            
        * 포인터 s를 움직이면서, 그 값이 (NULL)이 아닐 때 반복문 실행
            * split 기준 문자 c가 아닌 단어를 찾아서, 해당 단어의 길이만큼 메모리 할당
                * 할당에 실패하면 할당했던 모든 메모리를 ft_free() 함수를 사용해서 free후 종료
            * 할당한 메모리에 ft_strlcpy() 함수를 사용해서 단어를 복사 후 마지막에 널 삽입

        * 할당한 메모리의 마지막 값에 (NULL) 삽입 후 할당한 메모리의 첫 주소 반환


<hr>

#### 3. Makefile
* Makefile
    * Make 란
        * 자주 사용하는 명령어를 자동화 한 툴
        * 미리 컴파일하여 사용할 수 있도록 하는 라이브러리를 만듦

    * 매크로 (변수선언)
        * (변수이름) = (내용)
        
        ```
        NAME = libft.a                                                   // 라이브러리 이름

        CC = gcc                                                         // c 컴파일러
        CFLAGS = -Wall -Wextra -Werror                                   // c 컴파일 플래그
        AR = ar rcs                                                      // ar: archives; object 파일로 라이브러리를 만듦
        RM = rm -f                                                       // 삭제
        FILES = ft_memset ...                                            // 파일 이름


        // ./ft_memset.c
        SRCS_DIR = ./                                                    // 소스파일 디렉토리 설정
        SRCS = $(addprefix $(SRCS_DIR), $(addsuffix .c, $(FILES)))       // 소스파일 (addprefix: 접두사, addsuffix: 접미사)
        SRCS_B = $(addprefix $(SRCS_DIR), $(addsuffix .c, $(FILES_B))    // 보너스 파트 소스파일
        
        
        // ./ft_memset.o
        OBJS_DIR = ./                  // 오프젝트파일 디렉토리 설정
        OBJS = $(addprefix $(OBJS_DIR), $(addsuffix .o, $(FILES)))       // 오브젝트파일 (addprefix: 접두사, addsuffix: 접미사)
        OBJS_B = $(addprefix $(OBJS_DIR), $(addsuffix .o, $(FILES_B)))   // 보너스파트 오브젝트파일
        
        ```
        
        
    * rule (; how to compiling and linking)
        * (target) : (dependencies)        
                (bash command)
            * target: 빌드의 결과로 만들고자 하는 (목적) 파일
            * dependencies: 타겟을 만들기 위해 필요한 것(의존성)
            * command: 타겟을 빌드하기 위한 bash 명령어


        ```
        .c.o: $(SRCS)                            // 가장 최근에 수정된($<) .c 파일이 있다면 같은 이름의 .o 파일로 컴파일
            $(CC) $(CFLAGS) -c $< -o $(<:.c=.o)

        $(NAME): $(OBJS)                         // $(OBJS) 파일이 없다면 $(OBJS)를 만드는 명령을 실행 후,
            $(AR) $@ $^                          // 의존성 ($(OBJS))파일들로 ($^: 타켓 파일)의 이름을 갖는 라이브러리 생성

        bonus: $(OBJS_B)                         // $(OBJS_B) 파일이 없다면 $(OBJS_B)를 만드는 명령을 실행 후,
            $(AR) $(NAME) $^                     // 의존성 ($(OBJS_B))파일들로 $(NAME)의 이름을 갖는 라이브러리 생성 (의존성 파일의 변화가 있을 시 실행)
        // ar 자주 사용하는 옵션 
        // (r: 지정한 아카이브로 모듈(obj파일) 추가. 새로운 obj파일이면 추가, 기존 파일이면 치환)
        // (c: 아카이브 (라이브러리 파일) 생성)
        // (s: 아카이브 인덱스를 생성 - 아카이브 인덱스를 생성하지 않으면 링크 속도가 느려지고, 시스템 환경에 따라서는 에러가 발생)

        all: $(NAME)                             // NAME 실행

        clean:                                   // 오브젝트 파일들 삭제
            $(RM) $(OBJS) $(OBJS_B)

        fclean: clean                            // clean 실행 후 라이브러리 삭제
            $(RM) $(NAME)

        re: clean all                            // clean 실행 후 all 실행

        ```




    * .PHONY
        * 더미 타겟과 같은 이름의 파일이 존재할 때 make가 이미 빌드가 끝났다고 판단하여 해당 더미 타겟 명령어를 수행하지 않음 -> .PHONY 구문으로 정의하여 방지
        * 내가 정의한 target
        
        ```
        .PHONY: bonus all clean fclean re
        ```
        
        
    * make
        * Makefile에  정의된 규칙들 중 한 개의 타겟을 실행
        * make (타겟을 명시하지 않는 경우 Makefile의 룰 중 '.'으로 시작하는 타겟을 가진 룰이나 패턴 룰을 제외한 최상단에 있는 룰을 실행)
        * make target (명시된 타겟 룰 실행)

        


## 7. 학습 내용에 대한 개인적인 총평

* ft_split() 함수를 작성하는데 piscine 때 final exam 에서 막혔던 문제라서 겁을 많이 먹었다. 오늘도 시험때와 비슷하게 구현했지만, 역시나 오늘도 함수 구현에 있어서 많은 어려움을 겪었다. 원래 매개변수로 들어온 것의 값을 바꾸는 것을 좋아하지 않아서 자주 사용하지 않았는데, 매개변수로 들어온 값을 바꾸면서 코드를 작성하다보니 계속 틀렸다. 포인터를 이동하다 보니 잘못된 메모리에 접근하는 경우가 많았다. 혼자서 해결했으면 오늘 안에 절대 하지 못했을 것 같은데 동료학습을 핑계로 친한 분들께 편하게 물어봤다. 모두 적극적으로 나서서 해결해주려 했고, 결국 ft_split() 함수 안의 while()문 상의 오류임을 확인할 수 있었다. 앞으로는 while()문 안에서 포인터의 이동이 있을 때 메모리 접근에 좀 더 주의해야겠다.
* 원래 Makefile의 기본 문법이나 사용 등을 아무것도 몰라서 지금까지 다른 사람이 올려놓은 Makefile로 unit-test 혹은 Libfttest를 진행했는데, 오늘은 디스코드로 (jji, jiwchoi) 과 전화하면서 Makefile을 함께 공부했다. 혼자 학습할 때 보다 훨씬 이해가 빨랐고, 아마 동료학습이 없었다면 Makefile을 하루안에 공부하지 못했을 것 이다. 부족한 부분이 있겠지만, 내가 새롭게 작성한 Makefile 은 모두 이해를 할 수 있었다. Makefile을 작성할 줄 몰라서 라이브러리가 무엇인지, 왜 make를 사용해야하는지 이해할 수도 없었고, 사용하기도 싫었지만 이제는 Makefile 을 자주 사용할 것 같다. 
* 오늘로 libft 과제를 시작한지 일주일이 됐는데, libft 과제의 권장 기간은 일주일이었다. 권장 기간에 비하면 하루 이틀정도 늦었지만, 코딩에 서툰 학생이 일주일만에 해냈다는 것에 만족했다. 내일은 마지막으로 코드를 검토하고 제출해서 동료평가를 받을 생각이다. 부디 한번에 통과하기를!


## 8. 다음 학습 계획

* libft 과제 마지막 리뷰 후, 동료들과 질문사항 공유
* libft 과제 제출 후 동료 평가 받기
* libft 과제를 통과한다면 다음 과제 PDF 읽어보고 할 수 있는 것 하기
* libft 과제를 통과하지 못하면 어떤 것이 틀렸는지 수정 후 다시 제출


