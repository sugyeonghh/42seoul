## 1. 학습 날짜

* 2021-02-02(화)



## 2. 학습 시간

* 16:30 ~ 20:00(자가)



## 3. 학습 범위 및 주제

* 백준 알고리즘



## 4. 동료 학습 방법

* 해당사항 없음



## 5. 학습 목표

* 백준 문제 2개 풀기
  * 2941 크로아티아 알파벳
  * 2292 벌집



## 6. 상세 학습 내용

#### 1. 2941 크로아티아 알파벳

* 문제

  * 문제 설명

    * 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다. (표 참고)
    * 예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.
    * dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.

  * 입력

    * 첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 '-', '='로만 이루어져 있다.
    * 단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.

  * 출력

    * 입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.

  * 예제 1

    * 입력

      ```c
      ljes=njak
      ```

    * 출력

      ```c
      6
      ```

* 알고리즘

  * 입력받은 문자열에서 크로아티아 문자의 개수를 빼면 총 단어의 개수를 알 수 있다.

  * 입력받은 문자열의 길이를 cnt에 저장해놓고, 하나씩 접근하면서 해당 문자가 크로아티아 문자인지 확인한 후, 크로아티아 문자이면 cnt를 1씩 감소시킨다.

  * 코드

    ```c
    cnt = strlen(arr);
    for (int i = 0; i < strlen(arr); i++)
    {
      if (((arr[i] == 'c') || (arr[i] == 's') || (arr[i] == 'z')) && (arr[i + 1] == '='))
        cnt--;
      else if ((arr[i] == 'c' || arr[i] == 'd') && arr[i + 1] == '-')
        cnt--;
      else if ((arr[i] == 'l' || arr[i] == 'n') && arr[i + 1] == 'j')
        cnt--;
      else if (arr[i] == 'd' && arr[i + 1] == 'z' && arr[i + 2] == '=')
        cnt--; 
    }
    printf("%d", cnt);
    ```

    

<hr>

#### 2. 2292 벌집

* 문제

  * 문제 설명
    * (사진 참고) 위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.

  * 입력

    * 첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.

  * 출력

    * 입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.

  * 예제 1

    * 입력

      ```c
      13
      ```

    * 출력

      ```c
      3
      ```

* 알고리즘

  ```
  1 : 1 -> 1 + 6 * 0
  2 ~ 7 : 2 ->  ~ 1 + 6 * 1
  8 ~ 19 : 3 -> ~ 1 + 6 * 2
  20 ~ 37 : 4 -> ~ 1 + 6 * 3
  38 ~ 61 : 5 -> ~ 1 + 6 * 4
  ```

  * 동작이 위와 같으므로 6의 배수만큼 동작하는 것을 알 수 있다.

  * 코드

    ```c
    scanf("%d", &N);
    range = 1;
    cnt = 1;
    while (range < N)
    	range += 6 * cnt++;
    printf("%d", cnt);
    ```



## 7. 학습 내용에 대한 개인적인 총평

* 벌집 문제를 저번에 해결하지 못했었는데 다시 풀어보니 저번에 왜 못풀었는지 어이가 없을 정도다. 그래도 오늘은 금방 풀었으니까 다행이다. 16줄 밖에 안되는데 이런거에 겁먹고 못푼게 아쉽다. 자신감을 가져야겠다. 

* get_next_line 을 빨리 검사받아야겠다. 빨리 검사받고 ft_printf 로 넘어가는 게 좋을 것 같다. 어차피 지금 printf를 못하고 있으니까 그게 더 이득이고 시간도 아깝지 않을 것 같다. get_next_line 알고리즘을 잊기전에 얼른 검사를 받아야겠다.



## 8. 다음 학습 계획

* get_next_line 검사
* ft_printf 구현..



