## 1. 학습 날짜

2020-12-26(토)


## 2. 학습 시간

* 15:00 ~ 20:00 (자가)
* 20:30 ~ (익일)02:30 (자가)


## 3. 학습 범위 및 주제

* libft 과제
    * war machine
        * ft_memcpy (수정)
    * ft_strmapi
    * ft_lstnew
    * ft_lstadd_front
    * ft_lstsize
    * ft_lstlast
    * ft_lstadd_back
    * ft_lstdelone
    * ft_lstclear
    * ft_lstiter
    * ft_lstmap

## 4. 동료 학습 방법

* 디스코드 및 슬랙을 통해 war-machine 테스트 동작 및 보너스 함수 (intra ID: jiwchoi, dongilee)
* 카카오톡을 통해 메모리 관련 함수에서 왜 (unsigned char * ) 를 사용해서 비교해야 하는지 공유 (intra ID: eunjikim)


## 5. 학습 목표

* unit-test 와 war-machine 두 개 모두 실행해보기
* part2 마무리 후 bonus part 작성
* ft_split 작성


## 6. 상세 학습 내용

#### 1. war-machine
* ft_memcpy (수정)
    * src값이 NULL인 경우 예외처리 삭제
* 이외의 모든 함수 수정


<hr>

#### 2. ft_strmapi.c
* ft_strmapi
    * SYNOPSIS           
        * `char *ft_strmapi(char const *s, char (*f)(unsigned int, char));`
    * DESCRIPTION
        * Applies the function ’f’ to each character of the string ’s’ to create a new string (with malloc(3)) resulting from successive applications of ’f’.
    * RETURN VALUES
        * The string created from the successive applications of ’f’. Returns NULL if the allocation fails.
    * EXTERNAL FUNCTS
        * malloc

* algorithm
    * (문자열 s) 혹은 (함수 포인터 f) 가 (NULL)이라면 (NULL) 반환
    * (문자열 s의 길이 + 1)만큼 새로운 문자열 할당 후, 할당에 실패하면 (NULL) 반환
    * 문자열 s에 접근해서 f() 함수에 적용시켜서 값을 바꾼 후, 해당 값을 새로운 메모리에 복사
    * 마지막에 (NULL) 문자 복사 후 할당한 메모리 반환


<hr>

#### 3. ft_lstnew.c
* ft_lstnew
    * SYNOPSIS           
        * `t_list *ft_lstnew(void *content);`
    * DESCRIPTION
        * Allocates (with malloc(3)) and returns a new element.  The variable ’content’ is initialized with the value of the parameter ’content’.  The variable ’next’ is initialized to NULL.
    * RETURN VALUES
        * The new element.    
    * EXTERNAL FUNCTS
        * malloc

* algorithm
    * 새로운 t_list 형 포인터를 선언 후, (t_list)형 새로운 메모리 할당 후 주소값 연결
    * 메모리 할당에 실패하면 (NULL)반환
    * 새로 할당한 메모리의 content값에 인자값으로 받은 content를 넣어주고, next 값에 NULL을 넣고 반환


<hr>

#### 4. ft_lstadd_front.c
* ft_lstadd_front
    * SYNOPSIS           
        * `void ft_lstadd_front(t_list **lst, t_list *new);`
    * DESCRIPTION
        * Adds the element ’new’ at the beginning of the list.
    * RETURN VALUES
        * None
    * EXTERNAL FUNCTS
        * None

* algorithm
    * lst 혹은 new 가 (NULL)이면 종료
    * lst가 new를 가리키게 하고 (new->next)에 원래 lst가 가리키던 것의 주소를 넣어야 하는데, lst를 먼저 바꾸면 원래 연결하고자 했던 주소가 사라지기 때문에 두 순서를 바꿈
        * 새로 삽입할 노드인 (new->next)를 원래 lst가 가리키던 것의 주소를 넣음
        * lst가 가리키는 것을 new로 바꿔줌


<hr>

#### 5. ft_lstsize.c
* ft_lstsize
    * SYNOPSIS           
        * `int ft_lstsize(t_list *lst);`
    * DESCRIPTION
        * Counts the number of elements in a list.
    * RETURN VALUES
        * Length of the list.
    * EXTERNAL FUNCTS
        * None

* algorithm
    * 노드의 개수를 저장할 새로운 변수 cnt를 선언
    * 현재 노드를 가리킬 포인터 변수 p 선언
    * 현재 노드 p의 값이 NULL일때까지 p의 위치를 바꾸면서 노드의 수를 세줌
    * cnt 반환


<hr>

#### 6. ft_lstlast.c
* ft_lstlast
    * SYNOPSIS           
        * `t_list *ft_lstlast(t_list *lst);`
    * DESCRIPTION
        * Returns the last element of the list.
    * RETURN VALUES
        * Last element of the list.
    * EXTERNAL FUNCTS
        * None

* algorithm
    * 현재 노드를 가리킬 포인터 변수 p 선언
    * 마지막 노드를 반환해야 하므로, (p->next)값이 (NULL) 일때까지 p의 위치 변경
    * p 반환


<hr>

#### 7. ft_lstadd_back.c
* ft_lstadd_front
    * SYNOPSIS           
        * `void ft_lstadd_back(t_list **lst, t_list *new);`
    * DESCRIPTION
        * Adds the element ’new’ at the end of the list.
    * RETURN VALUES
        * None
    * EXTERNAL FUNCTS
        * None

* algorithm
    * lst 혹은 new 값이 (NULL)일 경우 종료
    * 마지막 노드의 위치를 가리키는 포인터 last를 선언한 후, ft_lstlast() 함수를 사용해서 해당 리스트의 마지막 노드 위치 반환한 것을 저장
    * last 가 (NULL)이면 (리스트에 노드가 아무것도 없으면) 처음 노드를 new로 넣어줌
    * 그렇지 않으면 (last->next) 에 new를 넣어줌


<hr>

#### 8. ft_lstdelone.c
* ft_lstdelone
    * SYNOPSIS    
        * `void ft_lstdelone(t_list *lst, void (*del)(void *));`
    * DESCRIPTION
        * Takes as a parameter an element and frees the memory of the element’s content using the function ’del’ given as a parameter and free the element. The memory of ’next’ must not be freed.
    * RETURN VALUES
        * None
    * EXTERNAL FUNCTS
        * free

* algorithm
    * lst 혹은 del 값이 (NULL)일 경우 종료
    * del() 함수가 노드의 content를 삭제하는 함수이기 때문에 삭제할 노드의 content 값인 (lst->content)를 넣어줌
    * free(lst)


<hr>

#### 9. ft_lstclear.c
* ft_lstclear
    * SYNOPSIS           
        * `void ft_lstclear(t_list **lst, void (*del)(void *));`
    * PARAMETERS
        * The adress of a pointer to an element.
        * The adress of the function used to delete the content of the element.
    * DESCRIPTION
        * Deletes and frees the given element and every successor of that element, using the function ’del’ and free(3). Finally, the pointer to the list must be set to NULL.
    * RETURN VALUES
        * None
    * EXTERNAL FUNCTS
        * free

* algorithm
    * lst 혹은 del 값이 (NULL)일 경우 종료
    * 현재 노드의 next 값을 저장할 포인터 변수 tmp를 선언
    * lst를 옮겨가면서 lst가 널일때까지 tmp에 * (lst)->next를 먼저 저장 후, ft_lstdelone() 함수를 사용해서 현재 노드를 삭제해준 후, lst 에 tmp 값을 넣어줌

    ```
    while (*lst)
	{
		tmp = (*lst)->next;
		ft_lstdelone(*lst, del);
		*lst = tmp;
	}
    ```
    
    
    
<hr>

#### 10. ft_lstiter.c
* ft_lstiter
    * SYNOPSIS           
        * `void ft_lstiter(t_list *lst, void (*f)(void *));`
    * PARAMETERS
        * The adress of a pointer to an element.
        * The adress of the function used to iterate on the list.
    * DESCRIPTION
        * Iterates the list ’lst’ and applies the function ’f’ to the content of each element.
    * RETURN VALUES
        * None
    * EXTERNAL FUNCTS
        * None

* algorithm
    * lst 혹은 f 값이 (NULL)일 경우 종료
    * 현재 노드의 위치를 저장할 포인터 변수 p 를 선언 후 lst 저장
    * p가 (NULL)이 아닐때까지 p의 주소를 옮기면서 (p->content)를 f() 함수에 넣어 값을 변환
    * 함수 f는 노드의 content를 바꿔주는 함수


<hr>

#### 11. ft_lstmap.c
* ft_lstmap
    * SYNOPSIS           
        * `t_list *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));`
    * PARAMETERS
        * The adress of a pointer to an element.
        * The adress of the function used to iterate on the list. 
        * The adress of the function used to delete the content of an element if needed.
    * DESCRIPTION
        * Adds the element ’new’ at the beginning of the list.
    * RETURN VALUES
        * The new list.  NULL if the allocation fails.
    * EXTERNAL FUNCTS
        * malloc, free

* algorithm
    * lst 혹은 f 값이 (NULL)일 경우 종료
    * 현재 노드의 위치를 저장할 포인터 변수 p 를 선언 후 lst 저장
    * 새로 할당한 리스트의 처음 주소을 저장할 포인터 변수 res 를 선언 후, NULL 저장
    * 새로 할당할 노드의 주소를 저장할 포인터 변수 new 선언
    * p가 (NULL)이 아닐때까지 p의 주소를 옮김 -> (while 문)
        * (p->content) 값을 f() 함수에 넣어서 변환시킨 후, 그 결과값을 가지는 노드를 새로 만들어줌
        * 만약 새롭게 노드를 할당하는 데 실패하면 ft_lstclear() 함수로 할당했던 모든 노드를 free 후 (NULL) 반환
        * 노드 할당에 실패하지 않았다면 ft_lstadd_back() 함수로 새로 할당한 노드를 새로 할당한 리스트의 맨 뒤에 넣어줌
    * 새로 할당한 리스트 반환
    ```
    while (p)
	{
		if (!(new = ft_lstnew(f(p->content))))
		{
			ft_lstclear(&res, del);
			return (0);
		}
		ft_lstadd_back(&res, new);
		p = p->next;
	}
    ```
    

## 7. 학습 내용에 대한 개인적인 총평
* 보너스 함수가 어렵다고 생각해서 보너스 문제를 시작할 때, 이제부터 시작이라고 생각했는데, 전공생이여서 그런지 자료구조 수업때 배운 연결리스트가 크게 도움이 되어 생각보다 금방 풀 수 있었다. 수업으로 처음 연결리스트를 접했을 때는 포인터와 구조체에 대한 이해도가 떨어져서 힘들었지만, 그 이후에 확실하게 공부해두어서 이번 과제는 하기 수월했다. 원래 작성했던 연결리스트보다 libft 보너스 과제가 더욱 구현하기도 간단했다. 
* 함수포인터를 처음 접해서 어떻게 사용하는 건지에 대해 공부를 해봤는데, 그것도 크게 어렵지 않았다. 하지만 PDF 에 함수포인터로 들어온 함수가 정확히 어떤 기능을 하는지에 대한 설명이 부족하다고 생각했다. 여러번 읽어보고 인자값을 정했다.
* 보고서에는 상세하게 작성하진 않았지만 war-machine 을 실행하고 난 후 작은 실수 혹은 약간의 디테일 상의 오류를 수정하는데 시간이 오래 소요됐다. ft_memmove()함수와 ft_strtrim함수의 오류를 고치는데 시간이 오래 들었다. 앞으로는 이해를 정확하게하고 예외처리도 꼼꼼하게 해야겠다.


## 8. 다음 학습 계획

* ft_split 함수 작성
* Makefile 공부 후 새로 작성
* 모든 함수 unit-test, war-machine 테스트 후 오류 처리
* norminette 테스트
* VNC로 과제 제출하는 git에 push


