## 1. 학습 날짜

2021-01-04(월)


## 2. 학습 시간

* 16:00 ~ 19:30 (자가)
* 20:30 ~ (익일)00:30 (자가)


## 3. 학습 범위 및 주제

* get_next_line 과제
    * 알고리즘 구상
	* 일부 구현

## 4. 동료 학습 방법

* 디스코드를 통해 get_next_line 함수 구현 도움 (intra ID: jiwchoi, jji, yoncho)


## 5. 학습 목표

* get_next_line 문제 이해
* get_next_line 알고리즘 구상 및 구현



## 6. 상세 학습 내용

#### 1. get_next_line.c
* get_next_line
    * PROTOTYPE           
        * `int get_next_line(int fd, char **line)`
	* TURN IN FILES
		* get_next_line.c, get_next_line_utils.c, get_next_line.h
	* PARAMETERS
		* 1: file descriptor for reading
		* 2: The value of what has been read
    * RETURN VALUES
        *  1 :  A line has been read
		*  0 :  EOF has been reached
		* -1 :  An error happened
    * EXTERNAL FUNCTS
        * read, malloc, free
    * DESCRIPTION
        * Write a function which returns a line read from a file descriptor, without the newline.

* get_next_line 문제 설명
	* 컴파일 시 BUFFER_SIZE를 입력받아서 BUFFER_SIZE 만큼 read() 함수로 읽어옴
	* 한 줄씩 읽어서 (line)에 연결
	* 성공적으로 읽어오면 return (1), EOF 에 닿으면 return (0), 에러 발생하면 return (-1)


* algorithm
	* 필요한 함수
		* ft_strlen(const char *s): 문자열 s의 길이 반환
		* ft_strchr(const char *s, int c): 문자열 s에 문자 c가 있으면 그 위치(인덱스) 반환, 없으면 (-1) 반환
		* ft_strjoin(const char *s1, const char *s2, int len): 새로운 공간을 할당해서 문자열 s1를 복사한 후 문자열 s2를 len만큼 붙임 
		* ft_bzero(void *s, size_t n): 문자열 s의 값을 n 바이트 만큼 0으로 저장
	
	* 버퍼를 (BUFFER_SIZE + 1) 만큼 char 형 배열로 만듦 -> BUFFER_SIZE = -1 인 경우 고려
	* BUFFER_SIZE 가 0 이거나 0 보다 작다면 버퍼에 저장할 수 없는 크기이기 때문에 (-1)을 반환
	* read() 함수로 fd에서 최대 BUFFER_SIZE 바이트 만큼 읽어옴
	* 성공적으로 읽어왔을 때, 읽어온 값 중 개행문자가 없다면 line 이 아니므로 임시 저장 공간 (tmp)에 저장함
		* 이때, tmp 는 읽어왔던 값이 저장되어 있어야 하므로 static 변수로 선언
		* tmp 는 한 라인을 연결할 때 까지 계속해서 버퍼에 있는 값과 연결해줌 (ft_strjoin 함수)
	* 읽어온 값 중 개행문자가 있다면 개행문자가 있는 위치 전까지가 한 문장이므로 static 변수에 있던 값과 버퍼에 저장된 값을 붙여준 후 line 에 연결


* code
	
	```
    int	get_next_line(int fd, char **line)
	{
		char		buf[BUFFER_SIZE + 1];
		static char	*tmp;
		int		idx;
		int		isread;

		if (BUFFER_SIZE <= 0)
			return (-1);
		ft_bzero(buf, BUFFER_SIZE);
		while ((isread = read(fd, buf, BUFFER_SIZE)) > 0)
		{
			if ((idx = ft_strchr(buf, '\n')) == -1)
				tmp = ft_strjoin(tmp, buf, isread);
			else
			{
				*line = ft_strjoin(tmp, buf, idx);
				tmp = ft_strjoin("", buf + idx + 1, BUFFER_SIZE - idx - 1);
				return (1);
			}
			ft_bzero(buf, BUFFER_SIZE);
		}
		*line = ft_strjoin(tmp, buf, idx);
		return (!isread ? 0 : -1);
	}
    ```
	

* 수정할 사항
	* 버퍼의 크기가 파일의 전체 데이터를 한 번에 읽을 정도로 크면 seg-fault 오류 발생
	* 개행문자가 연달아 있으면 정확한 처리가 되지 않음
	* free (메모리 누수 방지)


#### 2. get_next_line_utils.c
* ft_strlen(const char *s)
	* 문자열 s의 길이 반환


* ft_strchr(const char *s, int c)
	* 문자열 s에 문자 c가 있으면 그 위치(인덱스) 반환, 없으면 (-1) 반환


* ft_strjoin(const char *s1, const char *s2, int len)
	* 새로운 공간을 할당해서 문자열 s1를 복사한 후 문자열 s2를 len만큼 붙임 
	* s2의 값이 개행문자가 아닐때만 붙여줌 -> 개행문자가 여러개 나와도 처리해주기 위해
	
    ```
	char	*ft_strjoin(const char *s1, const char *s2, int len)
	{
		char	*res;
		int	i;
		int	j;

		if (!s1)
			s1 = "";
		res = malloc(ft_strlen(s1) + len + 1);
		i = 0;
		j = 0;
		while (*s1)
			res[i++] = *s1++;
		while (j < len)
		{
			if (s1[j] != '\n')
				res[i++] = s2[j];
			j++;
		}
		res[i] = 0;
		return (res);
	}
    ```


* ft_bzero(void *s, size_t n)
	* 문자열 s의 값을 n 바이트 만큼 0으로 저장
	* 버퍼를 초기화 하기 위한 함수인데 버퍼의 크기만큼만 0으로 초기화하기 위해 n을 넣음


## 7. 학습 내용에 대한 개인적인 총평

* get_next_line 을 구현하기에 앞서 문제 이해가 너무 힘들었다. 문제 이해만 이틀이 걸렸다. 혼자 이해한 것도 아니고 디스코드로 다른 동료들과 함께 분석한 것인데, 아무리 생각해도 subject.pdf는 문제를 한번에 이해하기 어렵게 작성된 것 같다. 동료학습은 필수요소인 것을 다시 한 번 깨닳았다. 
* 함수를 구현하는데, 먼저 읽었던 데이터들을 어떻게 저장을 해두고 어떻게 다시 불러오고 어떻게 free를 할 것인지 고민이 많이 되었다. 결국 static을 사용해서 구현을 하긴 했는데, free는 좀 더 고민을 해봐야한다. 먼저 읽었던 데이터들을 잃지 않고 이어붙인 것만으로 코딩 실력이 많이 발전됐다고 생각한다. 
* libft에서 static 변수를 함수의 이름 앞에 적어서 사용한 적은 있었는데, 단순히 서브함수들을 사용하기 위해 static 을 붙였을 뿐이어서 그 용도를 자세하게는 몰랐는데, 이번에 다시 한 번 이해하게 되었다. 함수를 새롭게 호출해도 static 변수에 저장이 되어있는 것이 신기하고 유용했다. 전역변수 대신 쓰기 좋은 변수인 것 같다.

## 8. 다음 학습 계획

* get_next_line 수정사항 수정
	* free (메모리 누수 방지)
	* 한 라인씩 정상 호출 되도록 수정
* netwhat 공부
