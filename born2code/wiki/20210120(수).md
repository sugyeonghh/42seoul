## 1. 학습 날짜

2021-01-20(수)


## 2. 학습 시간

* 19:00 ~ 24:30 (자가)


## 3. 학습 범위 및 주제

* 백준 알고리즘

## 4. 동료 학습 방법

* 해당사항 없음

## 5. 학습 목표

* 백준 알고리즘
	* 2751 수 정렬하기 2
		* 병합 정렬
		* 퀵 정렬


## 6. 상세 학습 내용

#### 1. 백준 알고리즘 - 2751 수 정렬하기 2
* 문제
	* N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
	* 시간 복잡도가 O(nlogn)인 정렬 알고리즘으로 풀 수 있습니다. 예를 들면 병합 정렬, 힙 정렬 등이 있지만, 어려운 알고리즘이므로 지금은 언어에 내장된 정렬 함수를 쓰는 것을 추천드립니다.

* 입력
	* 첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.

* 출력
	* 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

* 예제 1
	* 입력
   ```
    5
    5
    4
    3
    2
    1
    ```

	* 출력
    ```
    1
    2
    3
    4
    5
    ```

* 알고리즘 1 - 병합 정렬
	* 변수
		* N: 입력 받을 수의 개수
		* arr(배열): 입력 받은 수를 저장
	* 함수
		* mergeSort(int *arr, int p, int r)
			* arr[p ... r] 을 정렬하는 함수
			* 처음부터 마지막까지 반씩 나눠서 (merge()함수를 사용해서) 정렬한다.
			* 재귀함수의 형태로 가장 작은 단위부터 정렬할 수 있음
			* 코드 
            ```
            if (p < r)
            {
                q = (p + r) / 2;
                mergeSort(arr, p, q);
                mergeSort(arr, q + 1, r);
                merge(arr, p, q, r);
            }
            ```
            
		* merge(int * arr, int p, int q, int r)
			* 정렬된 두 개의 배열을 하나로 합치는 함수
			* 변수
				* tmp (배열): 정렬된 수를 임시로 저장할 배열
				* i: 첫 번째 배열의 시작 인덱스
				* j: 두 번째 배열의 시작 인덱스
				* t: tmp 의 인덱스
			* 배열의 i 번째 값과 j 번째 값을 비교해서 작은 값부터 tmp 배열에 저장한다. 
			* 첫 번째 배열의 값이 아직 남았다면 tmp 에 복사한다.
			* 두 번째 배열의 값이 아직 남았다면 tmp 에 복사한다.
			* 코드
            ```
            i = p;
            j = q + 1;
            t = 0;
            while (i <= q && j <= r)
                tmp[t++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
            while (i <= q)
                tmp[t++] = arr[i++];
            while (j <= r)
                tmp[t++] = arr[j++];
            i = p;
            t = 0;
            while (i <= r)
                arr[i++] = tmp[t++];
            ``` 
                
                
	* 입력받은 N개의 수를 저장한 배열을 mergeSort() 함수의 인자로 넘겨서 정렬한다.

	* 코드
    ```
    mergeSort(arr, 0, N - 1); // mergeSort 의 마지막 인자값은 배열의 마지막 인덱스여야 한다. 

    ```

* 알고리즘 2 - 내장함수 qsort 사용
	* 변수
		* N: 입력 받을 수의 개수
		* arr(배열): 입력 받은 수를 저장
	* 함수
		* qsort(정렬할 배열 주소, 요소 개수, 요소의 크기, 비교 함수) (내장함수: 퀵 정렬 함수)
			* 기준 원소를 기준으로 더 작은 값들을 왼쪽, 더 큰 값들을 오른쪽으로 배치한다.
			* 재귀함수를 사용하기 때문에 작은 단위부터 큰 단위로 옮겨오면서 정렬된다.
			* 함수 원형
				* LIBRARY
					* `#include <stdlib.h>`
				* SYNOPSIS
					* `void qsort(void *base, size_t nel, size_t width, int (*compar)(const void *, const void *));`
				* DESCRIPTION 
					* The qsort() function is a modified partition-exchange sort, or quicksort.
				* RETURN VALUES
					* The qsort(), qsort_b() and qsort_r() functions return no value.

		* ft_compare(const void *a, const void *b)
			* 인자로 전달받은 두 값의 차이를 반환하는 함수
			* 오름차순 정렬을 할 수 있다.
			* qsort의 마지막 인자값으로 들어가기 때문에 함수 원형에 있는 파라미터와 동일하게 작성함. 
			* 코드
            ```
            return (*(int *)a - *(int *)b);
            ```

	* 코드
    ```
    qsort(arr, N, sizeof(int), ft_compare);
    ``` 


## 7. 학습 내용에 대한 개인적인 총평

* 시간복잡도를 지켜서 풀어야하는 문제였기 때문에 오랜만에 병합 정렬과 퀵 정렬을 복습했다. 두 알고리즘 다 학교에 다니면서 익혔던 것이지만 시간이 지나면 쉽게 잊히는 알고리즘이기 때문에 역시나 잊었고, 새롭게 공부하는 마음으로 책을 피고 다시 공부했다. 그래도 복습을 많이 해뒀기 때문인지 금방 이해할 수 있었다. 코드를 바로 작성할 수는 없었지만 알고리즘을 정확하게 알고있는 것 만으로 다행이라고 생각했다.
* 퀵 정렬을 구현해본 적은 있지만 내장함수 qsort() 를 사용해본적은 없어서 qsort() 에 대해 공부했다. c에서 정렬을 해야할 때 항상 버블정렬 혹은 선택정렬을 구현해서 풀었지만 이제 내장함수 qsort() 가 있는 것을 알았으니 활용을 잘 해서 익혀야겠다. 
* 오랜만에 정렬에 대해서 복습해서 좋았다.


## 8. 다음 학습 계획

* netwhat 평가
* 정렬 정리
* gnl 구현
* 백준 알고리즘 문제 풀기
