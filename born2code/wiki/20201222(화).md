## 1. 학습 날짜

2020-12-22(화)


## 2. 학습 시간

13:30 ~ 19:20 (자가)


## 3. 학습 범위 및 주제

* libft 과제
    * ft_strlcpy.c
    * ft_strlcat.c
    * ft_strchr.c
    * ft_strrchr.c
    * ft_strnstr.c
    * ft_strncmp.c
    * ft_atoi.c
    * ft_isalpha.c
    * ft_isdigit.c
    * ft_isalnum.c
    * ft_isascii.c
    * ft_isprint.c
    * ft_toupper.c
    * ft_tolower.c
    * ft_calloc.c
    * ft_strdup.c


## 4. 동료 학습 방법

* 디스코드 및 슬랙을 통해 ft_strchr, ft_strnstr 등 libft 과제에 필요한 함수 학습 (intra ID: jji, jiwchoi)
* 음성 전화를 통해 libft 과제 unit_test하는 방법 공유 및 ft_putchar_fd 함수 구현 방법 공유 (intra ID: eunjikim)


## 5. 학습 목표

* piscine에서 구현했던 함수를 복습하고 과제가 요구하는 대로 새롭게 작성한다.


## 6. 상세 학습 내용

#### 1. ft_strlcpy.c
* strlcpy
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `size_t   strlcpy(char *restrict dst, const char *restrict src, size_t dstsize)`
    * DESCRIPTION
        * strlcpy() copies up to dstsize - 1 characters from the string src to dst, NUL-terminating the result if dstsize is not 0.
        * src에 있는 문자열을 (dstsize - 1) 만큼 dst에 복사한 후, 마지막에 널문자 삽입.
    * RETURN VALUES
        * The strlcpy() and strlcat() functions return the total length of the string they tried to create. For strlcpy() that means the length of src.

* ft_strlcpy
    * dst와 src가 NULL인 경우 NULL포인터 반환
    * dstsize가 NULL이면 (src의 길이) 반환, 그렇지 않으면 dst에 문자열 src를 (dstsize - 1) 만큼 복사한 후 마지막에 널 문자를 넣고 (src의 길이) 반환


<hr>

#### 2. ft_strlcat.c
* strlcat
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `size_t   strlcat(char *restrict dst, const char *restrict src, size_t dstsize)`
    * DESCRIPTION
        * strlcat() appends string src to the end of dst. It will append at most dstsize - strlen(dst) - 1 characters. It will then NUL-terminate, unless dstsize is 0 or the original dst string was longer than dstsize(in practice this should not happen as it means that either dstsize is incorrect or that dst is not a proper string).
        * src에 있는 문자열을 (dstsize - 1) 만큼 dst문자열 뒤에 복사한 후, 마지막에 널문자 삽입.
    * RETURN VALUES
        * The strlcpy() and strlcat() functions return the total length of the string they tried to create. For strlcat() that means the initial length of dst plus the length of src.

* ft_strlcat
    * dstsize가 0이면 (src의 길이) 반환
    * dstsize가 dst의 길이보다 작거나 같으면 (dstsize + src의 길이) 반환
    * 위 경우가 아니면,
        * dst의 마지막 부분에 문자열 src를 복사한 후, 마지막에 널 삽입.
        * (dst의 길이 + src의 길이) 반환


<hr>

#### 3. ft_strchr.c
* strchr
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `char *strchr(const char *s, int c);`
    * DESCRIPTION
        * The strchr() function locates the first occurrence of c (converted to a char) in the string pointed to by s. The terminating null character is considered to be part of the string; therefore if c is '\0', the functions locate the terminating '\0'.
    * RETURN VALUES
        * The functions strchr() and strrchr() return a pointer to the located character, or NULL if the character does not appear in the string.

* ft_strchr
    * 문자열 s가 (NULL)이 아닐때, 문자열 s에 직접 접근해서 문자 c와 비교
    * 문자 c가 (NULL)이면 문자열 s의 마지막 (NULL 포인터) 반환
    * 문자열 s에 NULL이 아닌 문자 c가 있으면 그 위치를 반환


<hr>

#### 4. ft_strrchr.c
* strrchr
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `char *strrchr(const char *s, int c);`
    * DESCRIPTION
        * The strrchr() function is identical to strchr(), except it locates the last occurrence of c.
    * RETURN VALUES
        * The functions strchr() and strrchr() return a pointer to the located character, or NULL if the character does not appear in the string.

* ft_strrchr
    * ft_strchr와 기본 동작은 비슷하지만 문자열 s의 마지막 값부터 비교하는 것이 다름


<hr>

#### 5. ft_strnstr.c
* strnstr
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `char *strnstr(const char *haystack, const char *needle, size_t len);`
    * DESCRIPTION
        * The strnstr() function locates the first occurrence of the null-terminated string needle in the string haystack, where not more than len characters are searched. Characters that appear after a '\0' character are not searched. Since the strnstr() function is a FreeBSD specific API, it should only be used when portability is not a concern.
    * RETURN VALUES
        * If needle is an empty string, haystack is returned; if needle occurs nowhere in haystack, NULL is returned; otherwise a pointer to the first character of the first occurrence of needle is returned.

* ft_strnstr
    * 문자열 needle이 NULL이면 haystack 반환
    * haystack에 직접 접근하여 needle과 비교하는데, 같은 문자열이 있으면 문자열 needle 이 위치한 haystack의 위치 반환
    * 비교는 haystack의 처음부터 len 인덱스 까지만 비교해야함
    ```
    while ( *haystack && len-- >= ft_strlen(needle))
	{
		if (*haystack == *needle)
		{
			if (!ft_memcmp(haystack, needle, ft_strlen(needle)))
				return ((char *)haystack);
		}
		haystack++;
	}
    ```
    * memcmp로 haystack과 needle을 (needle의 길이) 만큼 비교하는데, 이 과정에서 len 인덱스를 넘어갈 수 있기 때문에 while 의 조건에 (len >= needle의 길이) 를 넣어 제어함


<hr>

#### 6. ft_strncmp.c
* strncmp
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `int strncmp(const char *s1, const char *s2, size_t n);`
    * DESCRIPTION
        * The strncmp() function compares not more than n characters. Because strncmp() is designed for comparing strings rather than binary data, characters that appear after a '\0' character are not
     compared.
    * RETURN VALUES
        * The strcmp() and strncmp() functions return an integer greater than, equal to, or less than 0, according as the string s1 is greater than, equal to, or less than the string s2. The comparison is done using unsigned characters, so that '\200' is greater than '\0'.


* ft_strncmp
    * 두 문자열이 (const char)로 들어오기 때문에 (unsigned char * )로 캐스팅하여 저장할 두 개의 변수 s1, s2 필요
    * s1, s2로 메모리에 접근하여 문자열 비교
    * s1과 s2의 값이 NULL이 아니고, 두 문자열이 다를 때까지 비교
    * 두 문자열의 차를 반환


<hr>

#### 7. ft_atoi.c
* atoi
    * LIBRARY
        * `#include <stdlib.h>`
    * SYNOPSIS
        * `int atoi(const char *str);`
    * DESCRIPTION
        * The atoi() function converts the initial portion of the string pointed to by str to int representation.

* ft_atoi
    * piscine 에서 작성했던 atoi와 달리, 해당 atoi는 문자열 str의 처음에 나오는 모든 공백문자를 제거한 후, 양수 혹은 음수를 정해주는 문자(+ or -)를 단 한 개만 취급한다. 
    * 정수형 최대값과 최소값을 처리해야 하므로 (long long)형 변수에 숫자를 저장
    * 반환할 총 숫자의 자리수가 20이 넘어가면 특정 값을 반환하는데, 양수이면 (-1), 음수이면 (0)을 반환함


<hr>

#### 8. ft_isalpha.c
* isalpha
    * LIBRARY
        * `#include <ctype.h>`
    * SYNOPSIS
        * `int isalpha(int c)`
    * DESCRIPTION
        * The isalpha() function tests for any character for which isupper(3) or islower(3) is true.  The value of the argument must be representable as an unsigned char or the value of EOF.
    * RETURN VALUES
        * The isalpha() function returns zero if the character tests false and returns non-zero if the character tests true.

* ft_isalpha
    * 문자 c가 알파벳 대문자이거나 소문자이면 (1)을 반환하고, 그렇지 않으면 (0)을 반환
    * `return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));`


<hr>

#### 9. ft_isdigit.c
* isdigit
    * LIBRARY
        * `#include <ctype.h>`
    * SYNOPSIS
        * `int isdigit(int c)`
    * DESCRIPTION
        * The isdigit() function tests for a decimal digit character.
        * Regardless of locale, this includes the following characters only: ('0' ~ '9')
    * RETURN VALUES
        * The isdigit() and isnumber() functions return zero if the character tests false and return non-zero if the character tests true.

* ft_isdigt
    * 문자 c가 (0 ~ 9)이면 (1)을 반환하고, 그렇지 않으면 (0)을 반환
    * `return (c >= '0' && c <= '9')`;


<hr>

#### 10. ft_isalnum.c
* isalnum
    * LIBRARY
        * `#include <ctype.h>`
    * SYNOPSIS
        * `int isalnum(int c)`
    * DESCRIPTION
        * The isalnum() function tests for any character for which isalpha(3) or isdigit(3) is true.  The value of the argument must be representable as an unsigned char or the value of EOF.
    * RETURN VALUES
        * The isalnum() function returns zero if the character tests false and returns non-zero if the character tests true.

* ft_isalnum
    * 문자 c가 알파벳 대문자 혹은 소문자이거나, (0 ~ 9)인 숫자이면 (1)을 반환하고, 그렇지 않으면 (0)을 반환
    * ft_isalpha 와 ft_isdigit 의 반환값의 OR 값을 반환하여 구할 수 있음
    * `return (ft_isalpha(c) || ft_isdigit(c))`;


<hr>

#### 11. ft_isascii.c
* isascii
    * LIBRARY
        * `#include <ctype.h>`
    * SYNOPSIS
        * `int isascii(int c)`
    * DESCRIPTION
        * The isascii() function tests for an ASCII character, which is any character between 0 and octal 0177 inclusive.

* ft_isascii
    * 문자 c가 (0 ~ 127)의 값을 가지면 (1)을 반환, 그렇지 않으면 (0)을 반환
    * 0177 은 8진법 표기법으로, 10진법으로는 127임
    * `return (c >= 0 && c <= 127);`


<hr>

#### 12. ft_isprint.c
* isprint
    * LIBRARY
        * `#include <ctype.h>`
    * SYNOPSIS
        * `int isprint(int c)`
    * DESCRIPTION
        * The isprint() function tests for any printing character, including space (' ').  The value of the argument must be representable as an unsigned char or the value of EOF.
    * RETURN VALUES
        * The isprint() function returns zero if the character tests false and returns non-zero if the character tests true.


* ft_isprint
    * 문자 c 가 ascii 코드 상 출력 가능한 문자이면 (1)을 반환하고, 그렇지 않으면 (0)을 반환
    * 출력 가능한 문자의 범위는 (32 ~ 126)이므로, 문자 c가 (32 ~ 126)의 값을 가지면 (1)을 반환하고, 그렇지 않으면 (0)을 반환
    * `return (c >= 32 && c <= 126);`


<hr>

#### 13. ft_toupper.c
* toupper
    * LIBRARY
         * `#include <ctype.h>`
    * SYNOPSIS
        * `int touuper(int c)`
    * DESCRIPTION
        * The toupper() function converts a lower-case letter to the corresponding upper-case letter.
    * RETURN VALUES
        * If the argument is a lower-case letter, the toupper() function returns the corresponding upper-case letter if there is one; otherwise, the argument is returned unchanged.

* ft_toupper
    * c가 알파벳 소문자이면 대문자로 바꾼 후 반환, 그렇지 않으면 본래의 c 반환
    * 소문자와 대문자의 값 차이는 (32)이므로, (c - 32)를 반환함


<hr>

#### 14. ft_tolower.c
* tolower
    * LIBRARY
        * `#include <ctype.h>`
    * SYNOPSIS
        * `int tolower(int c)`
    * DESCRIPTION
        * The tolower() function converts an upper-case letter to the corresponding lower-case letter.
    * RETURN VALUES
        * If the argument is an upper-case letter, the tolower() function returns the corresponding lower-case letter if there is one; otherwise, the argument is returned unchanged.

* ft_tolower
    * c가 알파벳 대문자이면 소문자로 바꾼 후 반환, 그렇지 않으면 본래의 c 반환
    * 대문자와 소문자의 값 차이는 (32)이므로, (c + 32)를 반환함


<hr>

#### 15. ft_calloc.c
* calloc
    * LIBRARY
        * `#include <stdlib.h>`
    * SYNOPSIS
        * `void *calloc(size_t count, size_t size);`
    * DESCRIPTION
        * The calloc() function contiguously allocates enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory. The allocated memory is filled with bytes of value zero
    * RETURN VALUES
        * If successful, calloc() function returns a pointer to allocated memory. If there is an error, they return a NULL pointer and set errno to ENOMEM.

* ft_calloc
    * size 만큼의 크기(자료형의 크기)를 count 만큼의 길이만큼 할당해야하므로, (size * count) 만큼을 할당
    * 만약 할당에 실패하면 (NULL 포인터) 반환
    * malloc()과 다르게 할당한 메모리를 (0)으로 채워야 하므로 메모리에 접근해서 값 (0)을 넣어줌
    * 할당한 메모리를 자료형 (void * )으로 캐스팅한 후 반환


<hr>

#### 16. ft_strdup.c
* strdup
    * LIBRARY
        * `#include <string.h>`
    * SYNOPSIS
        * `char *strdup(const char *s1);`
    * DESCRIPTION
        * The strdup() function allocates sufficient memory for a copy of the string s1, does the copy, and returns a pointer to it.  The pointer may subsequently be used as an argument to the function free(3).
        * The strndup() function copies at most n characters from the string s1 always NUL terminating the copied string.

* ft_strdup
    * strcpy() 함수와 달리 인자값으로 받은 문자열 s1을 새로 할당한 메모리에 복사한 후 반환함
    * (문자열 s1의 길이 + 1)만큼 새롭게 메모리를 할당, 할당에 실패하면 (NULL 포인터)를 반환
    * 새로 할당한 메모리에 문자열 s1을 복사한 후 메모리를 반환


## 7. 학습 내용에 대한 개인적인 총평
* 첫 날에는 환경에 익숙해지느라 오래걸린 것에 비해 오늘은 생각보다 많은 코드를 작성할 수 있었다. 그 중에 대부분이 piscine 때 작성했던 함수들이지만, 그때는 모르는 것들을 인터넷에 검색했다면, 지금은 이미 어떻게 동작하는 지 이해하고 있고 더욱 자세하고 정확하게 설명할 수 있다는 것이 달랐다. 확실히 한 번 이상 경험해본 코드가 작성하기 쉬웠다. 또 다시 잊지 않도록 복습을 잘 해야겠다.
* 익숙하다고 해서 금방 작성한 것은 아니었다. 나중에 libft에서 작성한 함수들을 가져다 쓰는 경우가 많다고 들었는데, 그 때를 대비해서라도 더 빠르게 작성할 수 있도록 함수들을 자주 복습하고 사용해야겠다.
* 원래 memory관련 함수들을 작성하는 것이 오늘 목표였지만, 덜컥 겁을 먹고 다른 것부터 작성하게 되었다.  시간 상 여유롭지 못했던 것도 맞지만, 메모리 관련 함수를 구현하는 것이 까다로울 것이라 생각되었다. 하지만 더이상 미룰 수 없으니 내일은 메모리를 꼭 공부해서 함수들을 모두 작성해야겠다.


## 8. 다음 학습 계획

* memory 구조와 memory함수 이해 및 작성
* unit-test 및 코드 수정
* part1 마무리 후 part2 접근하기
* 동료학습 더욱 적극적으로 하기
